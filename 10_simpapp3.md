# Еще немного компонентов и простых приложений

В этой главе мы будем работать с более сложным примером — программе по статистике продаж, описанным в (Ливенворт 1977). В упомянутом документе описывается приложение, в котором отсортированный файл сведений о продажах продуктов сравнивается с мастер-файлом продукта, создавая обновленный мастер-файл и два отчета: сводку по продуктам и сводку по районам и продавцам. Рисунок на следующей странице, который первоначально появился в (Моррисон 1978), показывает сеть FBP-процессов для этого приложения.

При традиционном подходе к созданию этого приложения мы сначала разделили бы сводку по району/продавцу на отдельный этап работы, которому предшествовала бы сортировка. Получилась бы функция, которая принимает два входных файла и генерирует три выходных (обновленный мастер, сводка продукта и ввод для сортировки, также называемый расширенными деталями). Эта функция должна передавать сведения о мастер-файлах, учитывать, что один из файлов обычно заканчивается раньше другого и обрабатывать возможные прерывания, обнаруживать нарушения последовательности и т.д. и т.п.

Как мы говорили в предыдущей главе, компонент `Collate` является ключом к упрощению такого рода приложений. Результирующая диаграмма выглядит следующим образом:

![fig10.1](http://www.jpaulmorrison.com/fbp/Fig10.1.gif)

Фрагмент 10.1

Где:

- `R` является компонентом чтения.
- `W` — компонент записи.
- `COL` — это обобщенный `Collate`, который объединяет два или более потока на основе заданных контрольных полей и вставляет IP-скобки между IP с разными значениями в контрольных полях. (Если используется только с одним потоком, то просто вставляет IP скобок — это случай второго `COL` на диаграмме).
- `P` является компонентом печати.
- `TR1` и `TR2` соответствуют Tran-1 и Tran-2 соответственно в статье Б. Ливенворта.
- `SRT` - это обобщенный компонент «Сортировка», который сортирует расширенные сведения, поступающие из Tran-1, по продавцам в пределах округа.

Выходные данные компонента `Collate` состоят из последовательностей групп, называемых «подпотоками», каждая из которых состоит из открывающей скобки, "мастера", нуля или более деталей и закрывающей скобки.

Схематично это можно показать следующим образом:

![fig10.2](http://www.jpaulmorrison.com/fbp/Fig10.2.gif)

Фрагмент 10.2

J-D. Warnier (1974) использует вертикальную форму приведенной выше диаграммы для определения входных и выходных файлов приложения и использует ее для определения структуры кода, который должен их обрабатывать. К сожалению, программирование с управлением потока требует, чтобы один из файлов становился "драйвером" с точки зрения общей структуры программы, так что, если между структурами разных файлов есть какие-либо существенные различия, структуру программы становится все труднее и труднее понимать и, как следствие, поддерживать. В FBP эта структура сообщает нам важные вещи именно о тех компонентах, которые получают или отправляют этот конкретный поток и потому остается чрезвычайно полезным средством для понимания логики приложения.

Входной поток для `TR1` показан с использованием расширения нотации J-D Warnier:

![fig10.3](http://www.jpaulmorrison.com/fbp/Fig10.3.gif)

Фрагмент 10.3

---

Конечно, в книге Warnier'а приведенный выше тип диаграммы используется для описания реальных файлов, а не FBP-потоков, но он довольно хорошо переносится на IP, потоки и подпотоки. Последний столбец, конечно же, это поля внутри IP.

Другой методологией, тесно связанной с методологией Warnier'а, является методология Джексона, о которой уже упоминалось. Он использует горизонтальную версию этой записи, используя звездочки для обозначения повторяющихся элементов. Используя его нотацию, эта диаграмма может выглядеть так:

![fig10.4](http://www.jpaulmorrison.com/fbp/Fig10.4.gif)

Фрагмент 10.4

Теперь, возвращаясь к нашему примеру, `TR1` генерирует три потока вывода: один из обновленных мастер-записей, один из записей-сводок, которые похожи на мастер-записи, но имеют другой формат (предназначены для компонента печати отчетов), и один поток "расширенных" деталей: добавлены подробные записи с полем "расширенная цена" (количество умноженное на цену за единицу).

Должны быть выполнены следующие расчеты:

```
extended price (in detail) :=
	quantity from detail * unit price from corresponding master record

product total (in summary) :=
	sum of extended prices over the details relating to one product master

year-to-date sales (in summary and updated master) :=
	year-to-date sales from incoming master record + product total
```

Фигура 10.5

Ранее мы говорили об использовании `non-loopers` со стеками для обработки вложенных потоков и подпотоков. Если мы добавим стек к нашим компонентам TR1, мы получим следующее «раздутое» изображение TR1 (стек не показан в определении сети — я просто показываю его, потому что он «внешний» по отношению к процессу):

![fig10.6](http://www.jpaulmorrison.com/fbp/Fig10.6.gif)

Фрагмент 10.6

Вот логика, которую нужно выполнить для каждого входящего IP (как видите, она очень похожа на логику, которую мы показали в предыдущей главе):

- Открытая скобка
  - создать контрольный IP
  - очистить поле `total quantity` в этом IP
  - положить этот IP на вершину стека
- Мастер-запись
  - взять контрольный IP со стека
  - скопировать из входящего мастер-IP информацию, такую как `unit price`, `year-to-date sales`, и т.д.
  - отбросить мастер-IP
  - заменить контрольный IP на вершине стека (надо убрать IP со стека, перед тем как обрабатывать его)
- Запись с деталями
  - взять контрольный IP со стека
  - обновить `total quantity` на `quantity` в IP деталей
  - вычислить `extended price` для деталей
  - отправить IP расширенных деталей на специальный выходной порт
  - вернуть контрольный IP на стек
- Закрытая скобка
  - взять контрольный IP со стека
  - создать отчёт
  - вычислить общую сумму (в долларах)
  - отформатировать IP с отчётом и отправить на выходной порт для отчётов
  - создать мастер-IP с информацией из контрольного IP и отправить на выходной порт "обновлённый мастер"
  - отбросить контрольный IP
  - стек теперь пуст, а когда прибудет новая открытая скобка, новый контрольный IP может быть положен на стек, сохранив глубину стека
- Конец данных
  - процесс закрывается, закрываются его выходные порты, что позволяет нисходящим процессам начать своё собственное завершение.

<!-- TODO: осознать + добавить в ISSUE про closing процессов-нод, что в рантайме, возможно, всё таки нужно понятие узла (обдумать связь с операторами)?

Также не забыть, что по завершении перевода этой главы стоит:

- перечитать предыдущую внимательно и подумать, что можно вынести в issues
- перечитать эту и поступить аналогично -->
