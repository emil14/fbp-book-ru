# Древовидные структуры

До сих пор я говорил об одиночных IP, путешествующих по сетям, как автомобили и автобусы в системе автомагистралей. Говорил, как потоки IP можно рассматривать как объекты более высокого уровня и как им, в свою очередь, можно придать более сложную структуру с помощью «скобочных» IP. Надеюсь, я показал, что с помощью этих концепций можно легко обрабатывать довольно сложные приложения.

Но что если мы хотим построить ещё более сложные структуры и перемещать их по сети как отдельные элементы? Потокам требуется время, чтобы пересечь соединение, и вы можете захотеть, чтобы вся структура данных была отправлена или получена в один момент времени. Как мы уже говорили, по сети перемещаются только дескрипторы, а для IP, содержащего один бит, перемещаться от процесса к процессу так же легко, как и для IP, содержащего мегабайт. Так почему бы не позволить сложным структурам перемещаться как единицам? Оказалось, что у этой идеи есть естественный аналог в реальной жизни (которая всегда убеждает нас в том, что мы на правильном пути!). Ранее мы упоминали идею, что _IP похожи на заметки_ — вы можете избавиться от них одним из трех способов: вы можете переслать их (send), отбросить (drop) или сохранить (используя различные методы, например, стек, сохранение на диск и проч.). Ну, и, конечно же, есть четвертое, что вы можете сделать с запиской (нет, не скомкать ее и не швырнуть в соседа) - прикрепить ее к другому листу бумаги, а затем сделать с полученным результатом одно из трех предыдущих действий. На самом деле вы можете прикрепить такую "составную заметку" к другому листу бумаги или к другой составной заметке и так далее.

Подобно тому, как составное сообщение может быть отправлено или получено как единое целое, так и структура связанных IP, называемая _деревом_, может быть отправлена или получена как единый объект. Как только процесс получил дерево, он может либо «пройтись» по нему (перейти от IP к IP по связующим звеньям), полностью либо частично разобрать его, либо уничтожить. Например, получатель может пройтись по дереву в поисках IP определенного типа, и отсоединить каждый найденный одним из стандартных способов. На следующей диаграмме показаны два процесса: один — сборка деревьев, а другой — их повторная разборка:

![fig12.1](http://www.jpaulmorrison.com/fbp/Fig12.1.gif)

Фрагмент 12.1

`A` преобразует серию из трех IP разных типов и размеров в дерево IP, а `B` разбирает деревья и выводит IP-компоненты (в другом порядке).

Во всех реализациях этой концепции ни один узел не мог происходить от более чем одного родительского узла, и мы не допускали никаких циклов — очень похоже на настоящее живое дерево! Я не думаю, что при этом мы потеряли много выразительной силы. Основная причина тут в том, чтобы разрешить работу правил владения и распоряжения FBP для IP.

Вы, наверное, уже поняли, что нам не нужны никакие специальные механизмы, покуда дерево собирается и разбирается за одну активацию одного процесса (активация подробно описана в главе о _правилах планирования_). На самом деле вы можете прочитать набор IP и построить массив указателей для сортировки - так работает ряд компонентов. Только когда дерево должно быть передано от одной активации к другой (от одного процесса к другому), необходимо учитывать правила расположения IP. Таким образом, на картинке выше процесс `A` получает (или создает) три IP, собирает их в одно дерево из 3 IP и отправляет их — в этом случае `A` начинает с «количества принадлежащих IP», равного 3, и постепенно уменьшает его до 0, сперва присоединив 2 IP к корню (счетчик теперь равен 1), а затем отправив дерево целиком (счетчик 1 становится равным 0). `B` получает один IP (счетчик идет от 0 до 1) и отсоединяет подключенные IP (счетчик идет от 1 до 3). Эти отсоединенные IP, конечно, должны быть утилизированы по обычным правилам. Если бы мы допустили какие-либо нарушения вышеприведенных правил о форме дерева, мы не смогли бы так легко отображать деревья и потоки.

Был поразительный пример того, насколько полезными могут быть деревья в FBP: в пакетном банковском приложении банковские счета были представлены сложными последовательными структурами на ленте. Каждая запись счёта состояла из заголовка аккаунта, за которым следовало переменное количество различных записей "хвоста", принадлежащих к большому количеству различных типов - остановки, удержания, элементов возврата и т.д. Проблема заключалась в том, что в большинстве случаев их можно было просто обрабатывать последовательно, но _иногда обработка последующих элементов потока приводила к изменениям, которые должны были отражаться в более ранних_. Например, для расчета процентов, инициированного определенным типом заключительной записи, может потребоваться обновление баланса счета в записи заголовка. Вы всегда можете сохранить заголовок и вставить его позже, но тогда он должен будет вернуться в правильное положение. Так или иначе, этого «прямого» доступа было довольно много, включая добавление и удаление записей хвостов. Используя обычное программирование, мы сделали это приложение чертовски сложным, ибо вся логика должна была быть скоординирована с точки зрения времени, и возникали временные конфликты между тем, когда что-то требовалось и когда оно становилось доступным! Речь шла о больших объемах таких структур — мы должны были иметь возможность обрабатывать около 5 000 000 каждую ночь. Когда взялись за дело с помощью FBP, то поняли, что можем решить эту задачу очень просто и естественно, преобразовав каждую последовательную запись в древовидную структуру. После того, как дерево было построено, обработка типа «прямой доступ» могла переходить от одного типа IP к другому в структуре дерева, добавлять или удалять IP и т.д. А затем все это можно было преобразовать обратно в линейную форму, когда мы закончим. Это решение оказалось простым для понимания, легко кодируемым и простым в обслуживании.

Теперь нарисуем простое дерево из четырех IP:

![fig12.1](http://www.jpaulmorrison.com/fbp/Fig12.1.gif)

Фрагмент 12.1

Верхнее поле представляет «корневой» IP, а все остальные IP прямо или косвенно происходят от него. На приведенной выше диаграмме (немного смешивая наши метафоры):

- `Х` это корень
- `Y` и `W` дочери `X`
- `Z` - дочь `Y`
- `Z` и `W` — листья (терминальные IP)
- `Y` — нетерминальный IP
