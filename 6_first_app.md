# Первое приложение на заранее запрограммированных компонентах

> "Вот что мне нравится в AMPS так это то, как много там, по сравнению с традиционным программированием, способов решить задачу (программист из большой Канадской компании).

Мы начнем эту главу с самой простой сети, которую только можно вообразить — ну, на самом деле, сеть только с одним процессом — самая простая, но это эквивалентно обычной программе! Простейшей сетью, по крайней мере, с одним соединением может быть Reader, питающий Writer, как показано ниже:

![fig6_1](http://www.jpaulmorrison.com/fbp/Fig6.1.gif)

Фрагмент 6.1

Эта сеть просто копирует один файл в другой, поэтому она эквивалентна утилите «копирования», которая есть практически в каждой операционной системе. Разница в том, что FBP позволяет комбинировать эти утилиты во всё более сложные функции. Утилиты, по моему опыту, предоставляют ряд функций, но всегда хочется чего-то немного другого. Функции, которые в них зашиты, часто не те, которые нужны. Это вполне понятно, учитывая сложность прогнозирования того, что люди сочтут полезным. Одна из альтернатив — объединить несколько утилит, записав промежуточные файлы на диск. FBP эффективно позволяет вам комбинировать несколько служебных функций, не требуя места на диске или ввода-вывода для чтения и записи с диска и на диск (таким образом, вы также используете меньше процессорного времени и, что более важно, меньше реально затраченного времени).

Предположим, вы хотите объединить функцию «копирования» с селектором, а затем отсортировать результат перед записью на диск. Просто свяжите нужные функции вместе:

![fig6.2](http://www.jpaulmorrison.com/fbp/Fig6.2.gif)

Фрагмент 6.2

На самом деле, **сеть даже не обязательно должна быть полностью подключена**. Например, следующее совершенно правильно и даже может быть полезно!

![fig6.3](http://www.jpaulmorrison.com/fbp/Fig6.3.gif)

Фрагмент 6.3

Я помню время, когда возможность написать программу, которая одновременно считывала карты и записывала их на ленту, читала ленту и выбивала записи, а также выполняла некоторую печать, считалась вершиной изобретательности программиста! Я обнаружил, что с FBP все, что вам нужно сделать, это указать связи между шестью процессами, как показано на диаграмме!

Теперь, если вы думаете об этой диаграмме как о способе **сделать что-то, а не контролировать, когда это происходит**, вы поймете, что три пары процессов, показанные выше, не обязательно должны выполняться одновременно. Дело в том, что они могут, если есть соответствующие ресурсы, но они не обязаны - это не влияет на их правильное функционирование. **Думайте об этой сети как о трех железнодорожных путях, по каждому из которых движется поезд. Вы просто заботитесь о том, чтобы каждый поезд прибыл в пункт назначения, а не когда именно и как быстро**. В бизнес-приложениях нас интересует правильное функционирование, а не точное время событий. В реализации MVS FBP три «дорожки», вероятно, будут работать одновременно, поскольку ввод-вывод может перекрываться. В THREADS [реализация для ПК], в которых еще нет перекрытия ввода-вывода, они могут выполняться последовательно. Ни в одном из этих случаев порядок не определен. Я думаю, что нижний будет работать первым, но я не уверен! Естественно, это очень нервирует олдскульных программистов, привыкших контролировать каждую деталь, когда что должно произойти. Я буду постоянно возвращаться к этому моменту, поскольку он очень важен: **разработка приложений должна быть связана с функцией, а не с контролем времени, если время не является **частью функции****, как в некоторых real-time приложениях. Нам предстоит решить, что стоит внимания программиста, а что можно смело оставить машине. **Незнание точного времени, когда что-то произойдет, освобождает**, а не дезориентирует. Но да, некоторым программистам переход покажется довольно трудным!

Кстати, при сравнении 4GL и FBP меня поразил тот факт, что в FBP действительно можно делать все что угодно! Сила FBP заключается не в ограничении того, что могут делать программисты, а в инкапсуляции общих задач в повторно используемые компоненты или конструкции. Поскольку в традиционном программировании программа фактически представляет собой FBP-сеть из одного процесса, программист может игнорировать все средства FBP, если хочет, и в результате получается обычная программа. Это может прозвучать дерзко, но для меня это говорит о том, что мы ничего не убираем — мы добавляем совершенно новое измерение в процесс программирования. В то время как некоторые программисты действительно чувствуют ограничения с FBP, это происходит из-за необходимости выражать все как «черные ящики» с четко определенными интерфейсами между ними, а не из-за какой-либо потери функционала.

В оставшейся части главы мы соберем несколько простых примеров с использованием повторно используемых компонентов, но сначала мы должны составить каталог. Компоненты, которые не были упомянуты выше, являются довольно очевидными расширениями того, что было раньше. Некоторые элементы в этом списке следует понимать как разновидность некоторого компонента, а заранее определенные фрагменты кода. Например, в FBP-магазине может быть два или три модуля Sort с разными характеристиками:

- sort
- collate
- split
- assign
- replicate
- count
- concatenate
- compare
- generate reports
- read
- write
- transform
- manipulate text (может быть большой группой)
- discard

Давайте также добавим некоторые компоненты, которые оказались полезными во время разработки и отладки: dumper (который отображает шестнадцатеричные и символьные форматы) и компонент построчного принтера.

Мы не упоминали assign раньше. Я собираюсь использовать это для некоторых примеров, поэтому мы подробнее рассмотрим этот тип компонента. Этот компонент (или вид компонентов) просто вставляет значение в указанную позицию в каждом входящем IP и выводит измененные IP. Он имеет ту же форму, что и «фильтр», и его можно нарисовать следующим образом:

![fig6.4](http://www.jpaulmorrison.com/fbp/Fig6.4.gif)

Фрагмент 6.4

Где OPT получает спецификацию того, где во входящих IP-адресах должна происходить модификация и какое значение должно быть помещено туда. Например, мы можем разработать компонент Assign, который принимает IP опций, выглядящие следующим образом:

`3,5,ABCDE`

Это может означать, что «ABCDE» должен быть вставлен в 5 символов, начиная со смещения 3 от начала каждого IP. Это может показаться слишком простым, но можно комбинировать с другими функциями, чтобы обеспечить широкий спектр функций.
