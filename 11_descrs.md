# Описания данных и дескрипторы

Читатель заметит сходство в этой главе с объектно-ориентированными концепциями (ОО). Многое из нижеприведённого, возможно, устарело из-за появления ООП, плюс данный материал не есть суть потоко-ориентированного программирования, однако, читатель может захотеть прочитать его по историческим причинам или подумать о направлениях, в которых можно было бы расширить ООП. Поскольку FBP в значительной степени ориентирован на данные, имеет смысл попытаться управлять данными как можно более разумно.

В недавнем приложении для электронного бизнеса, созданном примерно в 2000 и 2001 годах с использованием Java-реализации FBP (теперь называемой JavaFBP), мы также создали ряд бизнес-объектов, которые описаны в разделе «Типы бизнес-данных». Хотелось бы верить, что при создании бизнес-приложений в ООП программисты не используют упрямо `int` или `float` для денежных значений!

---

Вы, вероятно, заметили, что всё это время мы предполагали, будто все компоненты "знают" формат своих IP. **Формат всех типов IP, которые может обрабатывать компонент, и типы IP, которые он может генерировать, становятся частью спецификации этого компонента**, так же как и общая функция. Если вы кормите что-то чем-то, что оно не может переварить, у вас обязательно будут проблемы. Как и в реальном мире!

В обычных программах вы обычно используете один и тот же формат для записи структуры или файла во всех подпрограммах программы - в FBP на самом деле только каждая пара соседних процессов должна согласовывать формат. Это означает, что процесс может получать данные в одном формате и отправлять их в другом. Если два соседних процесса (возможно, написанные разными людьми) используют разные форматы, все, что вам нужно сделать, это добавить промежуточный процесс преобразования.

Теперь предположим, что сначала вы хотели, чтобы два соседних процесса взаимодействовали посредством массивов из 20 элементов. Затем вы решаете, что это недостаточно гибко и остаетесь с массивами, но позволяете компонентам сообщать размер массивов во время выполнения. Это тип «метаданных», данных о данных, и их может быть столько, сколько нужно двум задействованным процессам. Например, в их соглашении может быть указано, что размер массива должен располагаться в виде отдельного поля (это может быть даже отдельный IP) перед массивом.

Большинство языков высокого уровня не очень хорошо поддерживают метаданные, и вы зависите от того, идут ли нужные вам форматы данных из коробки. Кроме того, старые данные легко могут начать не соответствовать программам, которые их обрабатывают. Есть, вероятно, [апокрифическая](https://ru.wikipedia.org/wiki/%D0%90%D0%BF%D0%BE%D0%BA%D1%80%D0%B8%D1%84) история, про то, что кто-то обнаружил несколько десятилетий назад, что большинство лент в ленточной библиотеке ВМС США были неразборчивы. Дело было не в том, что на лентах были ошибки ввода-вывода — физически они были в идеальном состоянии, — но проблема заключалась в том, что расположение записей на магнитных лентах было жестко закодировано в коде, и никто не знал, какие программы или код копирования описывали какие ленты! Я уверен, что такая проблема, если она когда-либо существовала, была решена давно! (Язык крепко [прижат к щеке](https://en.wikipedia.org/wiki/Tongue-in-cheek)!)

В DFDM мы расширили идею метаданных, представив описания времени выполнения, которые можно прикреплять к IP, проходящим через соединение. DFDM позволял создателю IP прикреплять к IP отдельно скомпилированный дескриптор, который использовался специальными службами DFDM, которые разрешали доступ к полям по имени. Всякий раз, когда создавался IP, функция `allocate` могла дополнительно задать дескриптор, который должен был быть постоянно связан с этим IP. Все IP одного типа будут иметь один и тот же дескриптор [налёт OO].

В DFDM эти услуги доступа назывались `GETV` и `SETV` («получить значение» и «установить значение»). У них было то преимущество, что если вы когда-либо хотели переместить поле (назовем его `AMOUNT`) из одного места в другое в структуре, содержащей его, вам не нужно было перекомпилировать все программы, ссылающиеся на него. Еще одно преимущество заключалось в том, что с помощью одного вызова компонент мог получить доступ к полю, которое может иметь разное смещение в разных типах входящего IP. Например, поле с именем `AMOUNT` может находиться в разных местах в разных типах IP, и компонент по-прежнему сможет получить к нему доступ или изменить его, если у IP есть дескрипторы. Службы DFDM `GETV` и `SETV` (и их потомки) были разработаны для вызова из ассемблера [S/370](https://ru.wikipedia.org/wiki/IBM_System/370) или поддерживаемых нами языков HLL. Они также предоставили ограниченные средства преобразования между одинаковыми форматами полей — например, между 2-байтовыми и 4-байтовыми двоичными полями, между различными длинами и масштабами упакованного десятичного числа или между изменяющимися и неизменяющимися символьными строками. Таким образом, вы можете указать, что хотите видеть бинарное поле размером 4 байта в рабочей памяти, хотя в IP оно занимает всего 2 байта. На момент написания эти сервисы не были реализованы для THREADS.

Без такой возможности схема входящих IP должна быть частью спецификации всех компонентов. Это указывает на еще одно преимущество `GETV` и `SETV`: если компонент заинтересован только в трех полях, в спецификации компонента должны быть упомянуты только имена этих конкретных полей, а не весь формат рассматриваемых IP.

Когда вы добавляете эту возможность к идее IP-опций, вы получаете мощный способ создания более удобных для пользователя черных ящиков. Например, вы можете написать `Collator`, в котором указаны два имени поля для основного и дополнительного ключа соответственно. Затем он будет использовать `GETV`, чтобы найти эти поля в правильном месте во всех входящих IP. «Сортировать по номеру продавца в филиале» кажется гораздо более естественным, чем «Сортировать по столбцам 1-6 и 7-9 для IP типа A, столбцам 4-9 и 1-3 для IP типа B» и так далее. Таким образом, намного лучше параметризовать обобщенные компоненты, используя имена символических полей, а не длины и смещения. Недостатком, конечно же, является производительность: компонент должен обращаться к задействованным полям с помощью соответствующих вызовов API, а не скомпилированных смещений. Однако дополнительное время процессора обычно является незначительным фактором затрат по сравнению со стоимостью человеческого времени, необходимого для массовых перекомпиляций, когда что-то изменяется, или, что еще хуже, стоимостью поиска и исправления ошибок, допущенных при внесении изменений!

Как только мы рассмотрели проблему передачи описаний данных между компонентами, то быстро столкнулись с проблемой - что «значат» данные: в случае наших обычных языков высокого уровня акцент всегда делался на создании желаемой машинной инструкции. Например, в IBM S/370 валюта обычно хранится в виде упакованного десятичного поля — 2 цифры на байт (кроме последнего байта, в котором есть одна цифра и знак), а суммы обычно хранятся с 2 десятичными знаками (они обычно имеют специальные названия, например, центы по отношению к долларам, новые пенсы по отношению к фунтам и т.д. — остались ли в мире валюты со смешанной системой счисления?). 

Поскольку инструкции на машине не заботятся о масштабе (количестве знаков после запятой), компилятор должен отслеживать информацию о масштабе и следить за тем, чтобы она правильно обрабатывалась для всех операций. (Возможно, вы могли бы использовать нотацию с плавающей запятой, но у нее есть другие характеристики, которые делают ее менее подходящей для бизнес-расчетов).

Теперь предположим, что компонент получает IP и пытается получить доступ к полю валюты в нем на основе скомпилированных знаний о форме IP. Если в скомпилированном коде указано, что поле имеет 2 знака после запятой, это то, что компонент «увидит». Итак, теперь мы можем произвести арифметические действия с числом, отобразить его в нужном формате (если мы знаем, с какой национальной валютой имеем дело) и так далее. Но обратите внимание, что формат IP определяется только в коде — код не может сказать, где поля действительно начинаются и заканчиваются. Итак, у нас есть своего рода взаимная зависимость: единственное определение данных находится в коде, а код жестко привязан к формату данных. Если вы хотите отделить их, у вас должно быть отдельное описание данных, которые могут запрашивать различные подпрограммы. Описания, которые могут быть присоединены к данным, независимо от того, какие подпрограммы будут работать с ними. Если реализовать это достаточно гибко, получиться даже получить доступ к более старым формам ваших данных (решить проблему «устаревших данных»).

