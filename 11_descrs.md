# Описания данных и дескрипторы

Читатель заметит сходство в этой главе с объектно-ориентированными концепциями (ОО). Многое из нижеприведённого, возможно, устарело из-за появления ООП, плюс данный материал не есть суть потоко-ориентированного программирования, однако, читатель может захотеть прочитать его по историческим причинам или подумать о направлениях, в которых можно было бы расширить ООП. Поскольку FBP в значительной степени ориентирован на данные, имеет смысл попытаться управлять данными как можно более разумно.

В недавнем приложении для электронного бизнеса, созданном примерно в 2000 и 2001 годах с использованием Java-реализации FBP (теперь называемой JavaFBP), мы также создали ряд бизнес-объектов, которые описаны в разделе «Типы бизнес-данных». Хотелось бы верить, что при создании бизнес-приложений в ООП программисты не используют упрямо `int` или `float` для денежных значений!

---

Вы, вероятно, заметили, что всё это время мы предполагали, будто все компоненты "знают" формат своих IP. **Формат всех типов IP, которые может обрабатывать компонент, и типы IP, которые он может генерировать, становятся частью спецификации этого компонента**, так же как и общая функция. Если вы кормите что-то чем-то, что оно не может переварить, у вас обязательно будут проблемы. Как и в реальном мире!

В обычных программах вы обычно используете один и тот же формат для записи структуры или файла во всех подпрограммах программы - в FBP на самом деле только каждая пара соседних процессов должна согласовывать формат. Это означает, что процесс может получать данные в одном формате и отправлять их в другом. Если два соседних процесса (возможно, написанные разными людьми) используют разные форматы, все, что вам нужно сделать, это добавить промежуточный процесс преобразования.

Теперь предположим, что сначала вы хотели, чтобы два соседних процесса взаимодействовали посредством массивов из 20 элементов. Затем вы решаете, что это недостаточно гибко и остаетесь с массивами, но позволяете компонентам сообщать размер массивов во время выполнения. Это тип «метаданных», данных о данных, и их может быть столько, сколько нужно двум задействованным процессам. Например, в их соглашении может быть указано, что размер массива должен располагаться в виде отдельного поля (это может быть даже отдельный IP) перед массивом.

Большинство языков высокого уровня не очень хорошо поддерживают метаданные, и вы зависите от того, идут ли нужные вам форматы данных из коробки. Кроме того, старые данные легко могут начать не соответствовать программам, которые их обрабатывают. Есть, вероятно, [апокрифическая](https://ru.wikipedia.org/wiki/%D0%90%D0%BF%D0%BE%D0%BA%D1%80%D0%B8%D1%84) история, про то, что кто-то обнаружил несколько десятилетий назад, что большинство лент в ленточной библиотеке ВМС США были неразборчивы. Дело было не в том, что на лентах были ошибки ввода-вывода — физически они были в идеальном состоянии, — но проблема заключалась в том, что расположение записей на магнитных лентах было жестко закодировано в коде, и никто не знал, какие программы или код копирования описывали какие ленты! Я уверен, что такая проблема, если она когда-либо существовала, была решена давно! (Язык крепко [прижат к щеке](https://en.wikipedia.org/wiki/Tongue-in-cheek)!)

В DFDM мы расширили идею метаданных, представив описания времени выполнения, которые можно прикреплять к IP, проходящим через соединение. DFDM позволял создателю IP прикреплять к IP отдельно скомпилированный дескриптор, который использовался специальными службами DFDM, которые разрешали доступ к полям по имени. Всякий раз, когда создавался IP, функция `allocate` могла дополнительно задать дескриптор, который должен был быть постоянно связан с этим IP. Все IP одного типа будут иметь один и тот же дескриптор [налёт OO].

В DFDM эти услуги доступа назывались `GETV` и `SETV` («получить значение» и «установить значение»). У них было то преимущество, что если вы когда-либо хотели переместить поле (назовем его `AMOUNT`) из одного места в другое в структуре, содержащей его, вам не нужно было перекомпилировать все программы, ссылающиеся на него. Еще одно преимущество заключалось в том, что с помощью одного вызова компонент мог получить доступ к полю, которое может иметь разное смещение в разных типах входящего IP. Например, поле с именем `AMOUNT` может находиться в разных местах в разных типах IP, и компонент по-прежнему сможет получить к нему доступ или изменить его, если у IP есть дескрипторы. Службы DFDM `GETV` и `SETV` (и их потомки) были разработаны для вызова из ассемблера [S/370](https://ru.wikipedia.org/wiki/IBM_System/370) или поддерживаемых нами языков HLL. Они также предоставили ограниченные средства преобразования между одинаковыми форматами полей — например, между 2-байтовыми и 4-байтовыми двоичными полями, между различными длинами и масштабами упакованного десятичного числа или между изменяющимися и неизменяющимися символьными строками. Таким образом, вы можете указать, что хотите видеть бинарное поле размером 4 байта в рабочей памяти, хотя в IP оно занимает всего 2 байта. На момент написания эти сервисы не были реализованы для THREADS.

Без такой возможности схема входящих IP должна быть частью спецификации всех компонентов. Это указывает на еще одно преимущество `GETV` и `SETV`: если компонент заинтересован только в трех полях, в спецификации компонента должны быть упомянуты только имена этих конкретных полей, а не весь формат рассматриваемых IP.

Когда вы добавляете эту возможность к идее IP-опций, вы получаете мощный способ создания более удобных для пользователя черных ящиков. Например, вы можете написать `Collator`, в котором указаны два имени поля для основного и дополнительного ключа соответственно. Затем он будет использовать `GETV`, чтобы найти эти поля в правильном месте во всех входящих IP. «Сортировать по номеру продавца в филиале» кажется гораздо более естественным, чем «Сортировать по столбцам 1-6 и 7-9 для IP типа A, столбцам 4-9 и 1-3 для IP типа B» и так далее. Таким образом, намного лучше параметризовать обобщенные компоненты, используя имена символических полей, а не длины и смещения. Недостатком, конечно же, является производительность: компонент должен обращаться к задействованным полям с помощью соответствующих вызовов API, а не скомпилированных смещений. Однако дополнительное время процессора обычно является незначительным фактором затрат по сравнению со стоимостью человеческого времени, необходимого для массовых перекомпиляций, когда что-то изменяется, или, что еще хуже, стоимостью поиска и исправления ошибок, допущенных при внесении изменений!

Как только мы рассмотрели проблему передачи описаний данных между компонентами, то быстро столкнулись с проблемой - что «значат» данные: в случае наших обычных языков высокого уровня акцент всегда делался на создании желаемой машинной инструкции. Например, в IBM S/370 валюта обычно хранится в виде упакованного десятичного поля — 2 цифры на байт (кроме последнего байта, в котором есть одна цифра и знак), а суммы обычно хранятся с 2 десятичными знаками (они обычно имеют специальные названия, например, центы по отношению к долларам, новые пенсы по отношению к фунтам и т.д. — остались ли в мире валюты со смешанной системой счисления?).

Поскольку инструкции на машине не заботятся о масштабе (количестве знаков после запятой), компилятор должен отслеживать информацию о масштабе и следить за тем, чтобы она правильно обрабатывалась для всех операций. (Возможно, вы могли бы использовать нотацию с плавающей запятой, но у нее есть другие характеристики, которые делают ее менее подходящей для бизнес-расчетов).

Теперь предположим, что компонент получает IP и пытается получить доступ к полю валюты в нем на основе скомпилированных знаний о форме IP. Если в скомпилированном коде указано, что поле имеет 2 знака после запятой, это то, что компонент «увидит». Итак, теперь мы можем произвести арифметические действия с числом, отобразить его в нужном формате (если мы знаем, с какой национальной валютой имеем дело) и так далее. Но обратите внимание, что формат IP определяется только в коде — код не может сказать, где поля действительно начинаются и заканчиваются. Итак, у нас есть своего рода взаимная зависимость: единственное определение данных находится в коде, а код жестко привязан к формату данных. Если вы хотите отделить их, у вас должно быть отдельное описание данных, которые могут запрашивать различные подпрограммы. Описания, которые могут быть присоединены к данным, независимо от того, какие подпрограммы будут работать с ними. Если реализовать это достаточно гибко, получиться даже получить доступ к более старым формам ваших данных (решить проблему «устаревших данных»).

Помимо информации о формате, вы также должны определить, какой тип данных содержит поле. Например, шестнадцатеричное значение:

`019920131F`

Может быть остатком на сберегательном счете (199 201,31 доллара США), но также может быть датой (31 января 1992 года). В зависимости от того, что это такое, мы будем выполнять самые разные операции. И наоборот, такая функция, как «отображение», которая применяется к обоим типам данных, приведет к очень разным результатам:

`$199,201.31`

или

`31st January, 1992`

Наши традиционные HLL будут видеть оба типа данных как `FIXED DECIMAL` (или `COMPUTATIONAL-3`). Опять же, только программа знает, какие данные находятся в поле (используя правильные операции). Существует также проблема того, какое представление используется. Мы все сталкивались с проблемой незнания того, является ли `01021992` 2-ым января (американская конвенция) или 1 февраля (британская конвенция). Таким образом, мы должны где-то записать, какие цифры представляют день, месяц и год. Таким образом, полное описание нашего поля имеет то, что мы могли бы назвать _базовым типом_ (упакованным десятичным числом со знаком), _длиной_ (и, возможно, масштабом), _доменом_ и _представлением_. Некоторые системы используют стандартное представление для «внутренних» данных или, по крайней мере, формат, который менее вариативен, чем «внешние» форматы, но элементы «данных о данных» (метаданные), которые я только что описал, довольно просты. (Базовый тип можно логически рассматривать как часть более общей информации о предметной области, но оказывается, что он полезен для разработки таких функций, как «тупые» процессы печати). В некоторых системах домен называется «логическим типом», а представление — «физическим типом».

Давайте теперь рассмотрим еще один пример ловушек программ, не знающих, с какими данными они работают. Предположим, вы по ошибке закодировали в программе следующий оператор PL/I:

`NET_PAY = GROSS_PAY * TAX;`

Где `TAX` — это рассчитанная сумма налога, а не налоговая ставка. **Компилятор не будет колебаться ни микросекунды**. Он беспечно умножит два десятичных значения вместе, чтобы получить другое десятичное значение (при условии, что именно так определены эти поля), даже если результат совершенно бессмысленен. Помните: **компьютеры делают то, что вы им говорите, а не то, что вы имеете в виду**! С другой стороны, человек сразу бы заметил ошибку (хочется верить), потому что мы знаем, что вы не можете перемножать валютные числа вместе. Компилятор знает, что результат умножения двух чисел с двумя знаками после запятой в каждом является числом с четырьмя знаками после запятой, поэтому он аккуратно удалит из результата два лишних знака после запятой (может быть, даже округлит результат до ближайшего цента). Чего он не может сделать, так это сказать нам, имеет ли вообще вся эта операция какой-то смысл!

Еще одна (реальная) проблема с валютными цифрами заключается в том, что инфляция будет постоянно увеличивать их, не увеличивая их реальную стоимость. Если в 1970 году 11 цифр казалось вполне достаточно, то в 1992 году для такого же рода информации может потребоваться 13 или 15 цифр. Подозрительно, когда ваша программа говорит, что вы потеряли _ровно_ миллиард долларов (хотя это хорошая подсказка, куда копать)! Было бы неплохо, если бы мы могли избежать встраивания такого рода информации в логику наших приложений. Если бы у нас было внешнее описание файла, мы могли бы либо использовать его динамически во время выполнения, либо преобразовать данные в какой-то стандартный внутренний формат — конечно, с большим количеством места для расширения! Другое место, где это влияет на наши системы, — макеты экрана и отчета. Как мы увидим, это также те области, где имеет смысл хранить описания отдельно и интерпретировать их во время выполнения. Чего мы не хотим, так это перекомпилировать наши бизнес-системы каждый раз, когда какая-то сумма в валюте становится слишком большой для полей, в которых она хранится.

Это еще одно наследие математического происхождения современных компьютеров — все рассматривается как математическая конструкция — целые числа, действительные числа, векторы, матрицы. В реальной жизни почти все имеет измерение и единицу измерения, например, вес в фунтах или килограммах или расстояние в милях или километрах. Если вы умножите два расстояния вместе, вы должны получить площадь (акры или гектары); три расстояния дают объем в кубических сантиметрах, бушелях или литрах. _Суммы в валюте никогда нельзя перемножать, хотя их можно складывать и вычитать_. Вы также можете теоретически конвертировать валюту из долларов в фунты или франки в марки, но это немного другое, поскольку для этого потребуется доступ к актуальным таблицам курсов конвертации, и недавно мне было указано, что банки обычно любят взимать плату за конвертацию из одной валюты в другую, так что это не просто вопрос умножения суммы в валюте на коэффициент конвертации [хотя мы создали именно такое средство для недавнего приложения для электронного бизнеса]. _Даты даже нельзя складывать, хотя можно вычесть одну дату из другой_. Существует соблазн просто преобразовать даты в каноническую форму (количество дней от исходной даты — например, 1 января 1800 г.), а затем предположить, что вы можете делать с ними что угодно. На самом деле они остаются датами, только представленными по-другому, и вы все равно не можете их сложить... С другой стороны, вы можете делать такие вещи, как спросить, на какой день недели приходится дата, какая дата следующий понедельник, сколько рабочих дней между 30 июня и 10 августа и т.д.

До сих пор мы довольно часто использовали термин «представление». Некоторые из вышеперечисленных сложностей возникают из-за путаницы того, что представляют собой данные, с тем, как они представлены. **Данные на самом деле представляют собой значение, взятое из домена (определяемого как набор возможных значений)**. _Нас действительно не должно волновать, как данные представлены внутри_ — нас это волнует только тогда, когда нам нужно взаимодействовать с людьми или когда файл поступает из другой системы. Тем не менее, мы должны заботиться об этом каждый раз, когда взаимодействуем с текущими языками высокого уровня. Требования к взаимодействию с людьми включают в себя еще более интересные соображения, такие как национальные языки и национальные правила написания чисел и дат, которые должны быть, насколько это возможно, инкапсулированы в готовые подпрограммы.

Многоязычная поддержка становится все более важной областью. Некоторые азиатские языки используют двухбайтовое кодирование, которое отличается от машины к машине, а также от языка к языку. Пользователи компьютеров больше не считают, что им нужно учить английский язык, чтобы использовать приложение, хотя большинство программистов по-прежнему готовы это делать! Но более искушенные знают, что мы живем в условиях глобального рынка, и что компьютерам придётся подстраиваться под людей, а не наоборот. Во многих отношениях Канада была в авангарде этих изменений, поскольку она официально является двуязычной страной, и франко-канадцы исторически очень настаивали, и это правильно, чтобы их язык был написан правильно!

Если мы отделим представление от содержимого данных, то сможем рассмотреть множество возможных представлений для любого заданного фрагмента данных и решить, как лучше поддерживать преобразование из одного в другое. Однажды я насчитал 18 различных представлений дат, используемых в нашем магазине! Все они конвертируются между собой, если вы не пропускаете информацию (например, век). Я предполагаю, что около 2000 года многие программисты-пенсионеры будут призваны обратно в упряжь, обновить программы с 6-значными датами, чтоб те могли справиться с 21-м веком! [Ага! Мы были!]

Как мы сказали выше, представление данных внутри машины нас особо не касается. Это представляет интерес, когда мы говорим о внешнем использовании этих данных (чтение людьми, запись или чтение из баз данных или обработка HLL). В некотором смысле это напоминает объектно-ориентированное представление. Однако при отображении данных (например, числовых полей) мы обнаружили, что нам нужна «глобальная» информация для управления тем, как данные должны быть представлены, например:

- символ валюты (требуется ли и если да, то какой)
- является ли символ валюты плавающим или фиксированным
- разделители между группами из трех цифр (обязательно ли, и если да, то какой символ)
- разделители между целой частью и дробной частью (какой символ)
- следует ли указывать отрицательные значения, и если да, то как (DR, предшествующий -, следующий - и т.д.)

Кроме того, эти варианты часто идут «слоями»: может быть международный стандарт, национальный стандарт и стандарт компании, а конкретный отчет может даже использовать одно или несколько таких представлений для одной и той же области, например, суммы с разделителями и без. Сегодня уже недостаточно просто обеспечить по одному конверсионному объекту в каждом направлении. Представления возникают на границах между обязанностями и, как мне кажется, требуют сложной многоуровневой параметризации.

Учитывая, что нам приходится работать с существующими HLL [это было до Java!], лучшее, что мы можем сделать, это описать поля и максимально использовать умные подпрограммы для всей логики преобразования и взаимодействия. Это позволит нам реализовать все известные полезные функции, но не защитит от создания вредоносных. Объектно-ориентированные и некоторые новые языки высокого уровня со строгой типизацией движутся в этом направлении, но старые языки HLL не обеспечивают никакой защиты. Я подозреваю, что мы должны пойти дальше, поскольку в конечном итоге, вероятно, потребуется некоторая форма размерного анализа. Могут появиться аппаратные конструкции, учитывающие потребности бизнес-пользователей, и когда это произойдет, нам не придется проводить эти радикальные преобразования между такими разными парадигмами.

До сих пор мы говорили только о статических описаниях данных. DFDM также имел другой тип описания данных, который оказался очень полезным, который мы назвали «динамическими атрибутами». Динамические атрибуты также были формой метаданных, но были привязаны к IP, а также к их описаниям. Первым примером, который мы придумали, был атрибут `null`. Мы взяли этот термин из [IBM DB2](https://en.wikipedia.org/wiki/IBM_Db2), в которой столбец в таблице может иметь атрибут "может быть пустым". Это означает, что отдельные поля в этом столбце будут иметь дополнительный бит информации, указывающий, является ли конкретное значение нулевым или нет, что означает либо «не знаю», либо «не применяется». Некоторые авторы считают, что эти два случая различны, и на самом деле последнего можно избежать, разумно выбрав классы сущностей, но первый, безусловно, очень полезен. В интерактивных приложениях DFDM мы часто использовали «нулевое значение» для обозначения полей, которые не были заполнены на панели конечным пользователем.

Атрибут `null` также хорошо работает с другим динамическим атрибутом, который мы также сочли полезным: атрибутом `modified`. Предположим, что в интерфейсе приложения есть ряд полей, некоторые из которых не имеют значений, известных программе. Целесообразно отображать «пустые» поля как пустые или, возможно, со знаками вопроса. Если пользователь заполняет одно или несколько полей, их атрибуты изменяются на «модифицированные» и «ненулевые». Затем эта информация может использоваться кодом приложения для предоставления логики, отвечающей пользователю. Мы обнаружили, что такая логика часто встречается в типе приложения, которое называется «помощь в принятии решений»: здесь вы часто видите экраны с большим количеством полей, и становится важно знать, какие из них были изменены пользователем.

Многие приложения кодируют `null` как значение «по умолчанию», например. двоичные нули, но есть ряд форматов, которые не имеют неиспользуемого значения, например, двоичный, так как же узнать, есть ли у вас ноль яиц или неизвестное число? Означает ли пустое название улицы и номер в адресе, что мы не знаем полного адреса домовладелицы или что она живет в сельской местности, где почтальон всех знает по именам? Кроме того, мы не увидели преимущества в том, чтобы смешивать идею нулевого значения и значения по умолчанию — каково подходящее количество яиц по умолчанию?

Там, где DB2 имеет специальную обработку только для атрибута `nullness`, DFDM обобщил эту идею, чтобы вы могли прикреплять любые динамические атрибутивные данные к любому полю любого IP, например. `null` и `modified`, а также «color», «номер ошибки» и т.д. Поскольку мы чувствовали, что не можем предсказать, какие типы данных динамических атрибутов мы могли бы захотеть прикрепить к полям IP, мы создали обобщённый механизм, управляемый собственным дескриптором (называемым, естественно, _динамическим дескриптором атрибута_ или DAD). Это позволяло прикреплять любое количество атрибутов к каждому полю, а также к IP в целом. Таким образом, у нас был «модифицированный» атрибут для каждого поля, но из соображений производительности у нас был «модифицированный» атрибут для IP в целом, который устанавливался, если какие-либо поля были изменены.

`Null` и `modified`, конечно же, являются логическими значениями (`boolean`), но мы допускали бинарные или даже символьные динамические атрибуты. Одним из динамических атрибутов символьного типа, который мы нашли очень полезным для интерактивных приложений, был «код ошибки». Предположим, процедура редактирования обнаружила, что числовое поле было введено пользователем неправильно: она затем пометила бы это поле кодом ошибки, указывающим «недопустимое числовое значение». Таким образом можно пометить любое количество полей. При повторном отображении IP, содержащего данные экрана, компонент отображения автоматически меняет все ошибочные поля на определенный цвет (в нашем случае желтый), устанавливает курсор под первым и помещает соответствующее сообщение об ошибке в поле сообщения экран. Не выходя из компонента (в среде IBM ISPF), пользователь мог просмотреть все поля ошибок, каждый раз отображая правильное сообщение об ошибке. Это было действительно одно из самых дружелюбных приложений, которые я когда-либо использовал, и всем им управлял один повторно используемый компонент, который вызывал службы ISPF (под IBM IMS вы можете делать то же самое, но, вероятно, потребуется набор компонентов, работающих вместе).

Некоторые авторы возражали против атрибута `null` на том основании, что он вводит трехзначную логику: да, нет и не знаю. По нашему опыту, на практике это никогда не вызывало путаницы и фактически значительно уменьшало сложность дизайна наших интерфейсов для конечных пользователей.

Последний момент был подсказан нашим ООП-исследованием: _типы IP часто связаны отношениями суперкласс-подкласс_. Это часто встречается при работе с файлами: можно знать, что вы имеете дело, скажем, с автомобилями, но не знать, пока не будет прочитана запись, что это за автомобиль. Было бы очень хорошо иметь возможность прикреплять дескриптор "car" к каждой записи по мере ее считывания, а затем "перемещаться вниз" по иерархии классов для данной записи, основываясь на каком-то индикаторе в записи. Это, в свою очередь, связано с вопросом совместимости дескрипторов: какие изменения разрешены между дескрипторами? Кажется разумным иметь возможность превратить обычный автомобиль в Volkswagen по мере того, как вы получите больше информации о нем, но не машину, скажем, в жука. Неприемлемо изменять код по мере выпуска новых моделей автомобилей. В более поздних версиях DFDM мы решили, что длина IP должна полностью определяться типом IP, т.е. если вы создали IP с заданным типом, длина будет получена из дескриптора типа и не может быть изменена. Тогда возникает вопрос: если вы меняете автомобиль на Pontiac (переходите из суперкласса в подкласс), становится ли IP длиннее или «неструктурированная» часть IP становится структурированной? Оставим это в качестве упражнения для читателя!
