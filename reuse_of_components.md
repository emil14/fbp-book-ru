# Повторное использование компонентов

> «Повторное использование в DFDM - это естественно. Технология DFDM не имеет себе равных в повторном использования по сравнению с другими в настоящее время» (из оценки DFDM, выполненной сайтом IBM I / S в США в 1988 году).

До сих пор мы говорили, что компоненты создаются «из воздуха» для решения конкретной проблемы. Вы могли подозревать, что я выбрал свои компоненты для иллюстрации определенных концепций, не беспокоясь о том, будут ли они полезны в реальном приложении. Что ж, хорошая новость, что типы компонентов, с которыми мы столкнулись, на самом деле являются теми, которые, как показывает опыт, очень полезны для создания реальных приложений. Плохая, что для создания полезных компонентов требуется большой опыт программирования и определенное творческое чутье. Это не должно удивлять, когда вы думаете о полезных инструментах, которые привыкли использовать в реальной жизни. Где и когда был изобретен первый молоток? Представьте себе целую серию «прото-молотов», например, оленьи рога, камни, прикрепленные к палкам и т.д. Которые постепенно превращаются в то, к чему мы привыкли сегодня... Возможно, мы должны уточнить, сказав «на Западе». В разных культурах появятся разные инструменты или разные формы одного и того же инструмента. На уроках антропологии я, кажется, помню, что у австралийских аборигенов есть замечательный инструмент, который представляет собой комбинацию всего, что они считают наиболее полезным в повседневной жизни, и при этом очень портативен. Это комбинация копья, щита, тарелки и зажигалки. Такие инструменты не изобретаются в одночасье - они требуют времени и опыта, требуя от многих творческих людей постепенного совершенствования. Лучшие инструменты всегда будут развиваться таким образом. Инструменты также могут выйти из употребления, поскольку потребность в них уменьшается, или их заменяют чем-то более эффективным - классическим примером являются глючные кнуты, но обычно это происходит незаметно для нас! Когда перестали ставить подножки на автомобили? Нет, не надо сразу звонить! Очевидно, что культура и инструменты, которые мы используем, тесно взаимосвязаны - у нас есть четкие представления о том, какой инструмент является правильным для данной работы, но в другой культуре на самом деле может быть другое определение того, что это за работа... На Западе мы считаем использование ножа и вилки «правильным» способом употребления пищи - несколько веков назад мы протыкали ее острием кинжала. Ножи и вилки, в свою очередь, означают, что приемлемая западная еда может включать в себя несколько очень больших кусков мяса или даже половину птицы. На Востоке, с другой стороны, люди очень давно используют палочки для отбивки, для чего необходимо, чтобы еда подавалась небольшими кусками. Обратите внимание, что выбор инструментов также помогает определить, какая часть сервировки выполняется посетителем, а какая - поваром за кулисами.

Еще одна вещь, которую мы должны учитывать, - это необходимость иметь возможность использовать инструмент в непредвиденных ситуациях. Полезный инструмент не должен быть слишком ограничивающим в способах его использования - люди всегда будут думать о большем количестве способов использования инструмента, чем когда-либо мог представить его первоначальный дизайнер. Уэйн Стивенс (1991) рассказывает историю о бортпроводнике, который использовал слуховой аппарат (тот маленький пластиковый стетоскоп, который вы подключаете к подлокотнику кресла), чтобы завязать занавески. Элегантный? Нет. Эффективно? Да! Мы не хотим делать молоток настолько умным, чтобы его можно было использовать только для гвоздей... Другой пример: почему некоторые функции UNIX (tm) имеют неочевидные имена? Известны случаи, когда инструмент изначально разрабатывался для одной работы, но люди обнаружили, что он даже более полезен для выполнения некоторых функций, которые первоначальный дизайнер не предвидел. Фактически это свидетельство надежности этих инструментов. Мы столкнемся с подобными примерами в FBP.

Подобно тому, как в приготовлении и потреблении еды есть две роли: повар и обедающий, в разработке приложений FBP есть две различные роли: создатель компонентов и пользователь компонента или разработчик приложения. Конструктор компонентов определяет спецификацию компонента, которая также должна включать ограничения на формат IP входящих данных (включая IP опций) и формат выходных IP. Спецификация не должна описывать внутреннюю логику компонента, хотя атрибуты иногда «просачиваются» из внутреннего во внешнее (ограничения на использование обычно бывают этого типа). Разработчик приложения создает приложения, используя уже существующие компоненты, или, если нужных нет, укажет новый компонент, а затем позаботится о его создании.

Разработчики компонентов и пользователи, конечно, могут быть одними и теми же людьми, но здесь задействованы два очень разных типа навыков. Это чем-то похоже на дизайнера недавно появившейся популярной игры, который признал, что не очень быстро ее решал - его умение заключалось в разработке игр, а не в том, чтобы играть в них. Разделение между производителями и пользователями настолько широко распространено в реальной жизни, что мы не обращаем на него никакого внимания, пока оно не исчезнет. В промышленности, как указывает Уэйн Стивенс, мы считаем само собой разумеющимся идею о том, что авиастроители не строят свои собственные стулья - они передают их в субподряд производителям стульев, которые, в свою очередь, передают ткань в субподряд производителям текстиля и так далее. Напротив, мир обычного программирования таков, как если бы каждый строитель проектировал свои собственные гвозди, пиломатериалы и гипсокартон с нуля. Поговорим о «изобретении колеса» - при разработке обычных приложений мы изобретаем резину, гайки и болты и даже форму колеса!

Хочу немного поговорить о том, как разрабатываются полезные компоненты. Маловероятно, что они возникнут из чистого подхода «сверху вниз» или из чистого подхода «снизу вверх». В первом случае вы не обнаружите гипсокартон, постепенно разбирая архитектурный чертеж дома. Во втором люди, которые придумывают полезные компоненты, должны быть готовы подвергнуть их тщательному тестированию в реальных жизненных ситуациях. Даже после того, как это будет сделано, ничего может и не выйти. Никто в отрасли не стал бы делать ставку на какой-нибудь непроверенный инструмент, который никогда не тестировался в полевых условиях (ну, как правило), и тем не менее мы часто делаем это при разработке приложений. Еще одна рекомендация Уэйна Стивенса - не создавать универсальный инструмент, пока вы не обнаружите, что делаете одно и то же три или четыре раза. В противном случае вы можете потратить много времени и усилий на функции, которые никто никогда не будет использовать, и можете оказаться не в состоянии отвечать на запросы клиентов о функциях, которые им действительно нужны.

В FBP многие базовые компоненты имеют аналоги в области, которая уже малоизвестна, но в течение ряда лет была очень продуктивной по сравнению с обобщенными компонентами, а именно, в машинах [Unit Record](https://en.wikipedia.org/wiki/Unit_record_equipment). В то время у нас были специализированные машины: сортировщики, табуляторы, подборщики и т.д. И люди научились связывать их (параметризовать) и очень эффективно создавать приложения. И вам не нужно было иметь высшее образование, чтобы приложения работали. Фактически, однажды я придумал, как решить проблему с коммутационной панелью табулирующей машины, прямо в ванне, по телефону, мокрый, даже без заметок или схемы, на которую можно было бы взглянуть!

Подобно тому, как Unit Record машины работали с потоками перфокарт, соответствующие компоненты FBP работают с потоками IP-адресов. Назовем эти компоненты «потоковыми». Примеры таких компонентов:

- sort
- collate
- split
- replicate
- count
- concatenate
- compare

Все они обладают тем свойством, что обрабатывают потоки данных и требуют очень мало информации о формате входящих потоков данных. Обычно они имеют четко определенные независимые от приложения функции.

Мы могли бы расширить список некоторыми компонентами общего назначения, которые доходят до уровня полей данных, но все еще не «понимают» бизнес-логику. Одним из таких компонентов может быть компонент обобщенного преобразования. Я считаю, что такой компонент, правильно параметризованный, на самом деле мог бы выполнять большую часть обработки в бизнес-приложении. Нан Шу из IBM в Лос-Анджелесе много писала о языке, который она называет ФОРМАЛЬНЫМ (Shu 1985) - его функция состоит в том, чтобы принимать описания файлов и преобразований между ними и использовать их для автоматического преобразования. Она обнаружила, что большая часть бизнес-обработки состоит из перемещения данных, изменения их кодирования и выполнения поиска в таблицах, например одно приложение может использовать номер для каждого штата США, а другое - двухсимвольное сокращение. Это говорит о том, что другим типом функций в этом же классе является обобщённая функция поиска по таблице, и на самом деле мы создали несколько таких для DFDM.

Существует еще один общий класс компонентов, известный как «технологически зависимые». Для создания этих компонентов обычно требуются специальные знания, но после создания их могут использовать люди, не обладающие такими техническими навыками. Таким образом, они заключают в себе специализированные знания. Обычно они пишутся на языке более низкого уровня. Несколько лет назад у нас был интересный пример этого: у нас был человек, который был экспертом по бумажной ленте. Бумажная лента была носителем информации со своими причудами. У неё есть специальные коды для различных целей и, в частности, есть соглашение об исправлении данных (вы пробиваете все дыры в специальном символе, который затем обрабатывается так, как будто никакого символа там вообще не было). Этот человек смог написать некоторые компоненты, которые генерировали обычные IP, так что никакому другому компоненту в приложении не нужно было знать, что вход был бумажной лентой. Вы можете создать и отладить приложение, используя обычный ввод-вывод, а затем, после того, как оно заработает, вы можете отключить модуль чтения и заменить его устройством чтения с бумажной ленты. Это, в свою очередь, означало, что тестирование могло проводиться без необходимости тестировщику монополизировать дефицитное (и медленное) оборудование.

Двумя наиболее широко используемыми технологически зависимыми компонентами являются «Последовательное чтение» и «Последовательная запись». Как и следовало ожидать из названий, они преобразуют записи файлов в IP и IP в записи файлов соответственно. Соответствующая пара компонентов чтения / записи может использоваться для кодирования и декодирования любого желаемого формата файла. Например, вы можете решить, что используемый вами носитель настолько дорог, что вы хотите сжимать данные по мере их хранения и расширять их по мере извлечения. Другой полезной парой функций может быть шифрование / дешифрование. Фактически, любая пара компонентов чтения / записи может рассматриваться как воплощение организации данных. Обобщая эту мысль, пара компонентов последовательного чтения / записи обеспечивает преобразование между форматом, подходящим для обработки, и линейным форматом на некотором носителе. Например, мы создали пару чтения / записи, которая была специализирована для выгрузки древовидных структур на линейный носитель и последующего их восстановления.

Возможно, вы уже заметили, что компоненты очень часто входят в согласованные пары, например разделение/объединение, чтение/запись, сжатие/расширение, шифрование/дешифрование и т.д. Это характерно для многих компонентов FBP - то, что один компонент делает, другой отменяет. _Фактически, комбинация компонента и его инверсии в должна приводить к потоку, идентичному исходному входному_ потоку, точно так же, как в математике умножение числа на его обратные результаты в единицу или составление функции с ее обратными результатами в функции идентичности.

Использование отдельных процессов чтения и записи не только дает разделение между логикой и вводом-выводом, что рекомендуется большинством методологий разработки приложений, но и фактически сокращает затраченное время. Причина этого удивительного результата в том, что в FBP процесс ввода-вывода, который должен ждать ввода-вывода, приостанавливает только себя - другие процессы продолжаются. Это означает, что приложения FBP обычно используют столько процессорного времени, сколько им позволяет операционная система. О производительности мы поговорим позже.

Еще одна интересная группа компонентов, созданная на основе Unit Record, - это компоненты, связанные с генерацией отчетов. К ним относятся такие функции, как разбиение на страницы и создание заголовков и оснований страниц, а также подсчет и подведение итогов, перекрестное основание и другие функции создания отчетов. Отчеты очень часто являются основным средством связи между приложением и людьми, которые его используют, и важность этих средств для среднего бизнеса подтверждается замечательной долговечностью [RPG от IBM](https://en.wikipedia.org/wiki/IBM_RPG), которая, хотя и часто считается устаревшей, все еще удовлетворяет реальную потребность на рынке. Позже в этой книге я опишу компонент создания отчетов, который широко использовался в нашем магазине.

Хорошим ориентиром для функциональности компонента является то, что его спецификация не должна превышать около страницы. Некоторые эксперты FBP зашли так далеко, что заявили, что _краткое изложение функции компонента не должно превышать одного абзаца и не должно содержать в себе слова «и»_. Еще одна рекомендация, которую мы сочли полезной, заключается в том, что _обобщенные компоненты не должны иметь более 4 портов_ (порта-массивы считаются за один порт). Конечно, эти рекомендации не являются взаимоисключающими, и они всего лишь принципы - некоторые компоненты объединяют настолько много функций, что их параметры по сути являются мини-языками, но их полезность может перевесить любое неудобство параметризации.

Последняя категория компонентов - это "бизнес-компоненты". Они воплощают бизнес-правила и должны быть относительно простыми, особенно если вы использовали другие категории компонентов, насколько это возможно. Мы можем представить бизнес-компоненты для разных сфер бизнеса - банковского дела, нефти и газа и так далее. Некоторые будут более математическими, другие - менее. Во всех случаях они представляют собой знания какого-либо бизнес-эксперта.

После функциональности одним из основных факторов, которые необходимо учитывать при проектировании бизнес-компонентов, является вероятность изменений. Есть разновидности бизнес-логики, которые практически никогда не меняются, а есть те что меняются каждый раз при запуске. Примером последнего может быть логика создания отчета о налогооблагаемой прибыли работника в конце года. Его меняют каждый год и запускают один раз в год. Было бы очень хорошо, если бы наши правительства могли отправлять один компонент многократного использования каждый год, который затем компании могли бы просто включить в свои собственные программы расчета заработной платы. Это также возвращает нас к вопросу о ролях: кто устанавливает новый модуль? Персонал, занимающийся разработкой приложений или операционный персонал? В первом случае у вас есть постоянная потребность в разработчиках приложений на неопределенный срок; Если второе, можете ли вы быть уверены, что новый компонент будет должным образом протестирован? С другой стороны, учитывая отставание в работе, с которым обычно сталкивается разработка приложений, то, что может быть просто загружено и запущено оперативным персоналом, безусловно, является привлекательным.

Было бы полезно, если бы такой компонент выполнял как можно больше проверки своих входных данных, чтобы убедиться, что он используется в правильном контексте. В идеале _компонент никогда не должен давать сбой_ - на практике, конечно, почти невозможно предотвратить разрушение одним компонентом данных другого, но, безусловно, можно добавить логику проверки для защиты от (скажем) ошибок формата данных. Многоразовый модуль также может потребовать, чтобы входящие данные были помечены определенным дескриптором. Затем, если требуемый формат данных изменится, вам просто нужно изменить имя дескриптора. _Имена дескрипторов обычно являются частью спецификации повторно используемого компонента_, так что это очень хорошо подходит.

Вышеупомянутое обсуждение на самом деле является еще одной формой старых дебатов о сравнении времени компиляции и времени выполнения. _В FBP время компиляции бывает двух видов: на уровне компонентов и на уровне сети_. Фактически параметры могут быть указаны внутри составного компонента и при этом оставаться вне элементарного компонента, которым они управляют! Я предсказываю, что в конечном итоге большая часть бизнес-логики будет воплощена в правилах, содержащихся в базах данных правил. Такие правила, написанные на подходящем языке, затем могут быть изменены людьми, не входящими в обычную группу разработчиков приложений. Эти правила могут даже не быть выражены в том, что программист распознал бы как язык программирования. Предшественником этого является IBM Patient Care System, в которой удивительное количество системной логики (включая макеты экранов) было представлено в виде таблиц, предназначенных для обновления старшим клерком или медперсоналом. Это было очень эффективно, поскольку обычно это были люди, которые должны были использовать систему и имели наибольший опыт работы с ней. Снова мы видим отдельные роли разработчика приложения и пользователя приложения. Если вас смущает такой контроль в руках конечных пользователей, либо внедрите системы авторизации, чтобы убедиться, что только нужные люди могут изменять ключевые данные, либо укажите правила в виде таблиц, жестко закодированных в определении приложения, но вне компонентов, которые относятся к ним. Таким образом, контроль остается за группой разработки приложений, но системы становится намного проще изменять и отлаживать. Однако нам действительно следует отказаться от требования, чтобы отдел DP выполнял всё обслуживание системы.

Если я прав в, что в конечном итоге мы увидим, что всё больше и больше бизнес-логики либо будет встроено в повторно используемые компоненты, либо зафиксируется в виде явных правил на диске, тогда роль текущих языков "более высокого уровня" в будущем должна уменьшиться. По нашему опыту мы обнаружили, что при наличии мощного набора повторно используемых компонентов люди будут делать все возможное, чтобы избежать написания кода HLL. В большинстве случаев более низкая производительность не имеет значения - в отчете Кендалла (1977) время выполнения средней программы сравнивается с человеко-месяцами, необходимыми для ее разработки. Программы, на разработку которых уходило 6 человеко-месяцев, могли выполняться в течение нескольких минут на протяжении всей своей жизни. Таким образом, _в большинстве случаев незначительное увеличение машинного времени не имеет значения_. Только в случае регулярного выполнения длительных заданий имеет смысл выполнять настройку производительности, и, как мы увидим в следующей главе, гораздо лучше настроить приложение FBP, чтобы выяснить, где ваши настоящие узкие места, чем пытаться угадать заранее и тратить время на оптимизацию кода, который не сильно влияет на производительность системы. На самом деле существует несколько способов тюнинга производительности в FBP-средах, выясним только сперва, в чем реальное преимущество.

Человеческое время гораздо важнее процессорного, и фундаментальный вопрос - на самом деле, как лучше всего тратить ценное человеческое время. Принимая решение о разработке нового компонента, вы должны принять во внимание ожидаемую отдачу от ваших инвестиций (сокращенно [«ROI»](https://en.wikipedia.org/wiki/Return_on_investment)). Каждый новый компонент должен быть задокументирован, протестирован, поддерживаться, рекламироваться и включаться в учебные материалы (ну, в идеале). Неудивительно, что наш опыт работы с FBP показывает, что разработчики приложений, использующие FBP, избегают написания нового кода - будучи ответственными людьми, они осознают бремя, которое они берут на себя, когда начинают кодировать новый компонент. Однако этого осознания недостаточно - мы должны изменить экономику ситуации. _Код - это статья затрат_, как указали [Дейкстра](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%B9%D0%BA%D1%81%D1%82%D1%80%D0%B0,_%D0%AD%D0%B4%D1%81%D0%B3%D0%B5%D1%80_%D0%92%D0%B8%D0%B1%D0%B5) и другие, и тот, кто увеличивает общий объем кода, когда это не оправдано, будет стоить вашей компании денег сейчас и в будущем. Я начал предлагать, только наполовину в шутку, что программистов следует «наказывать» за каждую строку кода, которую они пишут! На самом деле некоторые улучшения программы предполагают удаление кода - отрицательная производительность?! Неоднократно отмечалось, что люди будут изменять свое поведение в соответствии с тем, как вы их измеряете - и компании, которые все еще измеряют производительность с помощью "Kloc" (тысячи строк кода), получают то, что заслуживают! И наоборот, тот, кто производит полезный компонент многократного использования, повышает продуктивность всех своих пользователей и заслуживает вознаграждения - некоторые компании уже начали это пробовать - ключевое слово, конечно же, «полезный». Н.П. Эдвардс, о котором я упоминал в предыдущей главе, сыграл ключевую роль в том, что IBM перешла на детали многократного использования в области аппаратного обеспечения, и он сказал мне, что ключевой прорыв в этой области также заключался в изменении экономики разработки аппаратного обеспечения.

А вот кто много говорил и писал о важности повторного использования - так это Т. Каперс Джонс (например, Jones 1992) - он также был осведомлен о моей работе в течение нескольких лет и поддерживал ее. Он активно продвигал использование независимых от кода метрик, таких как теперь хорошо известные функциональные точки Аллана Альбрехта, для измерения производительности и проделал большую работу по возможности повторного использования для снижения затрат на разработку приложений.

Как мы узнаем, полезен ли инструмент? Единственный способ - измерить его использование. Будут ли люди использовать это? Они сделают это, если он умещается в руке, и если вы окажете поддержку. Это, в свою очередь, означает, что у вас должна быть инфраструктура, позволяющая вашей компании использовать преимущества этой новой технологии, а также меры и стимулы, чтобы побудить людей двигаться в правильном направлении.

There is also the opposite question: what if the tool is "less than perfect"? Just as with real tools, there is no perfect tool - there are only tools which fit your hand more or less conveniently. Like many programmers who tend to be perfectionists, you may be tempted to postpone putting something on the market because you feel it isn't finished yet. The question should be: is it useful as it is? You can always enhance it as time goes on, provided you keep the interfaces stable (or provide "expansion ports" but maintain upward compatibility). In fact, after it has been in use for a while, you may find that the extensions people really want are not at all what you expected. Since your reusable component will hopefully be in widespread use by this time, it is important that you allow extension while maintaining upward compatibility. In FBP, the fact that ports are named helps you to do this; also parameters (described in the next chapter) should be designed to be extendible. Parameters can be in string format, with delimiters, or, if fixed form, it is a good idea to insert a few zero bits - these can always to changed to ones to indicate that there is an extension portion.

Another kind of modification which will happen to your modules occasionally is error correction. It is certainly a pleasurable feeling to know that you have improved a component which many people are or will be using, and you might think that your users will welcome the change with open arms. Unfortunately some of your users may have adjusted to the error, and will need to be convinced that you know what is right for them. The other thing users do is take advantage of undocumented features. I talked about a tool fitting the hand - it may fit the hand, even with an error in it. One team found an error in one of the DFDM components, but instead of telling us about it, they carefully compensated for it. When we fixed it, their programs stopped working! I think they were quite indignant for a while until everybody realized what had happened. We had to spend some time explaining that everyone would be much better off if we fixed the bug rather than leaving it the way it was! There is a very important rule which you should impress on your users: If it isn't documented, don't trust it. IBM learned the value of this one by bitter experience and has accepted its wisdom since the day some bright user discovered an undocumented instruction on one of the 700-series machines. When IBM started making invalid instructions result in exception conditions, I'm told quite a few programs in universities and other places stopped working!

The next question is: how will people find out about these components? There is a common misconception that reusable componentry doesn't work unless you have an elaborate catalogue, which people can interrogate to find the tool they want. On the other hand, Wayne Stevens has pointed out that most examples of reuse in everyday life are done very naturally without any catalogue. We know by heart most of the things we use commonly. Let's say you go into a hardware store because you want to attach a wood base onto a ceramic pot - you will be familiar with half a dozen types of fastener: glue, nails, screws, rivets, etc. Most of the time you will know exactly what kind of glue to use. In this case, let's say you are not quite sure what is best. You still don't have to scan the entire store - most of the time, you can go right to the shelf and start reading labels. What do you do if you are not sure where in the store to go to? You ask a store clerk, who may in turn pass you onto someone who is an expert in a particular area. If your requirements are really unusual, the clerk may have to consult a catalogue, but this is likely to be a rare case. The point is that effective reuse doesn't require catalogues, although they can certainly help.

To try to measure the productivity gains we were getting from DFDM within IBM Canada, we kept statistics on the amount of reuse taking place over a number of projects. The figures for three projects are shown in the following diagram (the numbers relate to components):

PROJECT Type Unique Occurrences Reuse Factor 1 / Figure of Merit
A Project 133 184 1.4 3.7

    Gen Purpose 	21 	305 	14.5

    Total 	154 	489 	3.2

    GP/T 	0.14 	0.62

B Project 46 48 1.0 7.7

    Gen Purpose 	17 	306 	18.0

    Total 	63 	354 	5.6

    GP/T 	0.27 	0.86

C Project 2 54 27.0 135.0

    Gen Purpose 	8 	216 	27.0

    Total 	10 	270 	27.0

    GP/T 	0.80 	0.80

In this chart, "project" means components coded specifically for the project in question, while "general purpose" means components that are off-the-shelf (already available and officially supported). "Unique" means separate components (separate pieces of code), while "occurrences" means total number of processes (component occurrences or network nodes). Thus project A used 154 distinct components, of which 21 came off the shelf, but accounted for 305 of the 489 processes (about 3/5). GP/T means General Purpose as a fraction of Total, and it is interesting to compare the GP/T for unique components against the GP/T for component occurrences.

The "Figure of Merit", to use Bob Kendall's phrase (Kendall 1988), is calculated as follows: number of project-coded components divided by the total number of processes. Since the first figure represents the amount of work a programmer has to do (apart from hooking together the network), while the second figure represents the amount of work the program is doing, we felt that the figure of merit was quite a good measure of the amount of real reuse going on. DFDM had been in use about 2 to 3 years in that shop, and we had about 40 off-the-shelf components available, so quite a lot of the common tasks could be done without having to code up any new components. However, when the programmer did have to code up components, you will notice that quite often this code could also be reused, giving reuse factors greater than 1 (Project C had a factor of 27.0). In the third example in the above chart, the programmer only had to write 2 components, although there were 270 separate processes in his program. (You can probably figure out that this project involved running 27 different files through essentially the same 10 processes - so it did a lot of work, with very little investment of programmer effort!).

[In Bob Kendall's "Figure of Merit", obviously smaller is better! In this version, I have shown the reciprocal as it seems to be more intuitive to have the larger number indicate better reuse.]

Although we thought at first that this last case was just a quirk, we turned up quite a few applications which were not that different from this one (e.g. Rej's letter quoted in the Introduction).

Here are some figures from an evaluation of DFDM quoted from at the beginning of this chapter:

    All of the function in the DFDM pilot application is performed by 30 unique coroutines (this is the number of coroutines that an individual would need to be familiar with in order to understand the function of the application).

    A total of 95 occurrences of these 30 coroutines make up the application ..... providing a 3:1 reuse ratio.

    These 95 coroutines are leveraged through the use of subnets and CNS [Compiled Network Specification] networks to perform the equivalent work of 225 unleveraged coroutines.

Some companies have tried to encourage people to write generalized code by offering them money or kudos. One counsel I would give them is that you need to monitor not how many components someone has written, but how often it is used. An appropriate analogy is the system of royalties in the publishing industry. Every time a module is used, the author should get some kind of token, be it money or recognition. This will ensure that your company will not accumulate a collection of wonderful, Rube Goldbergish gadgets sitting on the proverbial shelf, gathering dust.

Let us say that you are all convinced that reusable code is the way to go - how do we get it adopted in your particular shop? You will find (unless all your people are super-altruists) that the biggest enemy of reuse is not technology - it is human psychology. While many people will accept the new ideas enthusiastically, others will resist them, and for several different reasons. People who have become good at delivering applications under time pressure very often feel that they must at all costs maintain control of everything they use, and in fact all their experience has taught them that this approach works. Components developed by others will be on their critical path, and they will be pulled between the desire to reduce their own effort by using pretested components, and the fear that the components they are relying on will not be ready in time, will break or will not be maintained as the environment changes. They have to become convinced that someone will support these components - if necessary, on a 24-hour basis. This may not be necessary technically, but may be very necessary psychologically!

Another source of resistance is simply that some programmers love the bits and bytes and don't want to become mere combiners of precoded components. There is a role for these people, writing the components to specs. As we said above, two different roles seem to be emerging: component builders and component users. In my view the latter need skills very similar to those required by analysts. They need to be able to talk to users, gather requirements, and even build systems or prototypes of systems. For the more complex parts or parts which have to perform better, they can subcontract parts to the component builders. This is the domain where the programmer's programmers ("Merlins", as a friend of mine calls them) can shine. In some senses, a component becomes an encapsulation of their particular skill or knowledge. I have found that it makes sense to get "tighter" about the external specs and "looser" about how the code is built internally. This lets them express their creativity, while still serving the needs of the organization as a whole. Of course, it must not be so poorly written that it doesn't perform well! And it absolutely must deliver the function according to the specs! Once those are assured, then your only concern is maintainability. Generalized code should be maintainable, but you probably don't have to control the format of every internal label!

A programmer once said to me, "I don't like DFDM because I don't get dumps"! At the time I took this to mean that because programs built using FBP tend not to crash, it is hard for programmers to get a feel of how they work. Does not knowing how the engine of your car works make you nervous? It probably does affect some people that way, but most of us don't care. Later, I realized that it also brings up the very fundamental question of trust - if the users of a package don't trust the package or its vendor (same thing, really), they are not going to be happy... And trust is fragile: hard to build up, and easy to damage.

Let us suppose that your company has become convinced that developers should not keep "reinventing the wheel", but that, like most companies, you have only reached the stage where you are maintaining a library of shared subroutines. How do we get formalized sharing of components in place? Suppose I find out that Julia is working on a module which is pretty close to what I want but it needs some tweaking to fit my needs. In most shops, we don't even know what to call it. Companies that have just started to grapple with naming standards often think it's neat for module names to start with the project code. For instance, if I am managing project ABC, then I can name all my modules ABC-something. This way, I don't have to worry about my module names conflicting with those of other projects. Even the library names will often have ABC built into them! So, even to be able to find the code, we usually have to have some kind of enterprise-wide naming convention. Next question: who does the modification of the code and who pays for it? What if Julia's schedule slips and starts to impact my schedules? Even if everything goes really well, who will maintain it, document it, and support it?

Many writers about reuse agree that the only solution is to set up an independent department to write and maintain components. This department must have enough resources to do the job properly, which also involves publicising and selling their product. One tendency which must be resisted is that such departments often get tied up producing complex, generalized tools for a few users, or even for none - they just figure the component would be neat and they'll worry about selling them afterwards. Remember the principle of ROI: the company as a whole will get more bang for the buck out of a lot of simple tools, especially if they communicate well with each other, rather than from a few very complex ones. Since good tools will often start as special-purpose modules which some other group has found useful, there must be a path for promoting such ad hoc components to a place where other people can find them and rely on them. Our centralized software support department must have ways to beat the bushes for new and interesting components and must then have ways to evaluate whether potential customers are interested (otherwise why go to all that trouble?). It must also avoid getting sucked into writing or upgrading complex tools which have only a small market. It is a service organization, so it must be service quality oriented, not just a group of self-styled experts who know what is best for everyone else. It must become entrepreneurial, but not exclusively bottom-line oriented. In short, it must follow good financial and engineering practices. If this takes a major shake-up in the way your organization is structured, then you should really get started as soon as possible!

I believe that, unless companies start to bring engineering-type disciplines to application development, not only will they fail to take full advantage of the potential of computers, but they will become more and more swamped with the burden of maintaining old systems. You can't do a lot about old systems - I know, I've seen lots of them - but new systems can be built in such a way that they are maintainable. It should also be possible to gradually convert old programs over to the FBP technology piece-meal, rather than "big bang". A director I once worked for called this "converting an iceberg into ice-cubes"!

I believe all true disciplines follow a sort of cycle through time, which may be represented using the following diagram:

Figure 4.1

Innovation can only be founded on a base of solid knowledge of what went before - otherwise we are doomed to keep rediscovering the same old stale concepts. On the other hand, tradition without innovation cannot result in progress, and innovation is useless unless the word is gotten out to people who can make use of it. As I pointed out above, business application development has not really changed significantly since I started in the business in 1959 - but I really believe that now, at long last, we can start to see the promise of application development becoming a true engineering-style discipline.
