# Создание компонентов и еще несколько простых приложений

Сейчас я собираюсь описать несколько простых приложений, сочетающих повторно используемые компоненты и пользовательские. Мы начнем с довольно простого приложения для обработки текста, чтобы сделать рассмотреть несколько моментов в дизайне FBP-приложений. Это классическая проблема программирования, первоначально описанная [Питером Науром](https://en.wikipedia.org/wiki/Peter_Naur), широко известная как [Проблема Телеграммы](https://wiki.c2.com/?TelegramProblem). Необходимо написать программу, которая принимает на вход строки текста и генерирует выходные строки разной длины, не разбивая ни одно из слов в тексте (мы предполагаем, что ни одно слово не длиннее, чем размер выходных строк). Это оказалось на удивление сложно сделать с помощью традиционного программировании, и потому эту задачу часто используют в качестве примера в курсах. Пока учащийся не осознает, что ни входная, ни выходная логика не должны быть "основной линией", а основная линия должен быть отдельным фрагментом кода, задача которого в обработке одного слова за раз, он вязнет в куче запутанной логики. В FBP гораздо более очевидно, как подойти к проблеме, по следующим причинам:

- Слова явно упоминаются в описании проблемы
- Поскольку мы должны выбирать наши IP между каждой парой процессов, разработчику разумно рассматривать слова как IP где-то в реализации задачи. На самом деле было бы нелогичным намеренно избегать превращения слов в IP, учитывая описание проблемы.
- Основого процесса нет, поэтому у ученика нет соблазна превратить одну из функций в основной процесс.

Вывод `Read Sequential` и ввод `Write Sequential` оба состоят из потоков IP, содержащих слова и пробелы, поэтому кажется разумным, что нам нужен, как минимум, компонент для разложения записей на слова и соответствующий компонент для перекомпоновки слов обратно в записи. Учитывая определение проблемы, я не вижу необходимости в дополнительных компонентах, но хочу подчеркнуть, что единого правильного ответа нет. Помните рентабельность инвестиций? **То, что вы выберете в качестве основных черных ящиков, зависит от того, насколько часто они будут использоваться, а не от того, сколько будет стоить их создание.**

Давайте поместим наши два новых компонента на картинку:

![fig8.2](http://www.jpaulmorrison.com/fbp/Fig8.2.gif)

Фрагмент 8.2

Теперь у нас есть еще одна пара компонентов — на диаграмме я обозначил их `DC` (для DeCompose) и `RC` (для ReCompose). Компоненты всегда могут узнать реальный размер любого IP, поэтому нам не нужно указывать размер входящих IP в `DC` в качестве параметра. Однако `RC` не может знать, какой размер IP мы хотим, чтобы он создал, поэтому этот размер должен быть передан в качестве параметра его порту `OPTIONS` (мы не обязаны называть его так, подойдёт любое имя). Итак, давайте покажем варианты IIP на `RC`. `RSEQ` и `WSEQ` также должны будут знать идентификаторы файлов, с которыми они работают, поэтому наша диаграмма теперь выглядит так:

![fig8.3](http://www.jpaulmorrison.com/fbp/Fig8.3.gif)

Фрагмент 8.3

Для полноты картины я приведу некоторый возможный псевдокод для `DC` и `RC`. Помните, как только вы написали и протестировали `DC` и `RC`, их можно применять бесконечно. Так что стоит приложить усилия, чтобы сделать их "идеальными" (настолько близкими к совершенству, насколько вообще может быть программное обеспечение!). Одним из больших преимуществ FBP является то, что вы можете просто вставить `Display` процесс в любое соединение, например, между `DC` и `RC`, чтобы убедиться, что IP, проходящие через это соединение, верны. Так что тестировать очень легко.

В дальнейшем я предположил (но не показал на схеме), что входной порт обоих компонентов называется `IN`, а выходной порт называется `OUT`.

**DC (Разбить в слова)**:

```
receive from IN using a

do while receive has not reached end of data
        do stepping through characters of input IP
                if "in word" switch is off and current char non-blank
                        set "in word" on
                        save character pointer // начало слова
                endif
                if "in word" on and current char blank // слово кончилось
                        set "in word" off
                        build new string of length =
                                current pointer - saved pointer // разность индексов есть длина слова
                        create IP using new string
                        send created IP to OUT
                endif
        enddo
        drop a (original input IP)
        receive from IN using a
enddo
```

**RC (Собрать в записи)**:

```
receive output record length from IIP port // OPTIONS порт, в примере выше 80
drop this IP

create output IP and set it to all blanks // используя полученную длину
start at beginning of output IP // установка курсора

receive word IP from IN using a
do while receive has not reached end of data
        if received word will not fit into output IP
                send output IP to OUT // в текущем виде
                create new output IP and set to all blanks
                start at beginning of output IP
        endif
        move contents of word IP into next space in output IP // а если не влезет?
        if there is room for 1 more character
                move in single blank
        endif
        drop a
        receive word IP from IN using a
        if receive reached end of data
                leave loop
        endif
enddo
if output IP has at least one word in it
        send output IP to OUT
else
        drop it
endif
```

_(Прим.Пер - все комментарии добавлены мной.)_

Может быть, эту логику можно упростить, но компонент не обязательно должен быть простым внутри — он должен быть простым снаружи, и прежде всего он должен работать надежно! Этот момент действительно иллюстрирует фундаментальное различие между традиционным программированием и FBP: я только что показал некоторый псевдокод, и вы можете почувствовать, будто мы вернулись к традиционному программированию. Однако, выразить то, что я пытаюсь сказать можно по-другому - **поскольку мы можем программировать, это не означает, что мы должны это делать**. Большинство традиционных подходов к программированию и даже некоторые новые объектно-ориентированные подходы по-прежнему требуют создания нового кода. Многие подходы к повторному использованию основаны на поиске доступного исходного кода и его повторном использовании. Поскольку код является такой податливой средой и не имеет встроенной структуры компонентов, мы всегда создаем новые вещи и забываем, что результаты нашей работы могут жить долго после нас и что их поддержка, документирование и управление требуют затрат. Сколько раз мы слышали: "Легче написать с нуля, чем разобраться, что там накручено"? В FBP ориентация совершенно обратная: используйте то, что есть, и создавайте новое только в том случае, если вы можете оправдать усилия с точки зрения рентабельности инвестиций. Именно здесь опыт становится ценным: после того, как вы много раз выполнили одну и ту же работу, вы знаете, сочтут ли другие люди полезными такие компоненты, как `DC` и `RC`. Если вы знаете, что они этого не сделают, найдите другой способ выполнить эту работу!

Теперь у нас есть ещё пара полезных компонентов, но, конечно же, вам не нужно постоянно использовать их вместе. Предположим, мы просто хотим подсчитать количество слов в фрагменте текста. Мы уже упоминали компонент `Count` в главе 3 — он просто подсчитывает все входящие IP и в конце генерирует IP счетчика. У него есть _параметр, чувствительный к подпотоку_ (он генерирует один IP-счётчик для каждого входящего подпотока), но сейчас мы будем использовать его в его самой базовой форме. В этой форме он просто отправляет только что рассчитанный счетчик через выходной порт, в то время как исходные входящие IP отправляются через другой, если он подключен (это пример _необязательного порта_). Этот тип компонента иногда называют "ссылающимся" компонентом, что означает, что исходные входные IP передаются без изменений, а некоторая производная информация отправляется из другого выходного порта. Таким образом, результирующая структура будет выглядеть примерно так (мы не будем подключать необязательный вывод Count):

![fig8.4](http://www.jpaulmorrison.com/fbp/Fig8.4.gif)

Фрагмент 8.4

Мы можем бесконечно добавлять или изменять процессы! Эти изменения могут быть результатом изменения требований, новых требований или просто осознания того, что вы можете использовать компонент, разработанный для одного приложения, в другом. В главе о повторном использовании мы говорили о некоторых принципах проектирования компонентов для повторного использования.

В качестве еще одного более сложного примера, вместо подсчета слов, мы могли бы отсортировать их по алфавиту или по длине. После того, как мы отсортировали бы слова в алфавитном порядке, было бы здорово иметь возможность вставлять причудливые заглавные буквы между группами слов, начинающихся с одинаковых букв, как в некоторых словарях... Конечно, после того, как мы их отсортировали, мы должны исключить дубликаты. Результирующая диаграмма будет выглядеть так (частично):

![fig8.5](http://www.jpaulmorrison.com/fbp/Fig8.5.gif)

Фрагмент 8.5

Где `RDUP` означает "Удалить дубликаты", а `IHDRS` означает "Вставить заглавные буквы".

Неудивительно, что приложения для обработки текста очень продуктивно работают с обобщенными компонентами. Это также область применения, в которой система UNIX® оказалась очень продуктивной. Механизм канала UNIX очень похож на потоки данных FBP, за исключением того, что связь UNIX основана на использовании потоков символов, тогда как связь FBP осуществляется посредством структурированных IP-адресов.

Прекрасным примером такого рода приложений для обработки текста является публикация П.Р.Юинга "[Конкорданс](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%BA%D0%BE%D1%80%D0%B4%D0%B0%D0%BD%D1%81) Украинской Библии" (1988 г.) — она была запрограммирована с использованием DFDM, и Филип обнаружил, что DFDM очень хорошо подходит для такого типа работы. Недавно он закончил Конкорданс для [Коса](<https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%81%D0%B0_(%D0%BD%D0%B0%D1%80%D0%BE%D0%B4)>) с помощью компьютерной программы THREADS. Он сообщает, что, потратив от 100 до 150 часов на разработку этого Конкорданса с использованием обычного (не FBP) программного обеспечения, ему в конце концов пришлось бросить его незаконченным. С помощью THREADS он смог создать законченный Конкорданс, потратив около 40 часов (конечно, не считая времени на ввод библейского текста). Он сказал мне, что, по его мнению, большим преимуществом FBP является тот факт, что оно упрощает сложность приложения, и 40 часов против более чем 100, безусловно, подтверждают это.

- Производительность: сортировка, которая выполняется как отдельный шаг, должна использовать файлы для ввода и вывода, а "контрольные поля" должны находиться в одном и том же месте в каждой входной записи. Если мы представим Sort как компонент, работающий "из потока в поток", то IP данных, которые должны быть отсортированы, больше не нужно сначала записывать в файл (и не нужно извлекать из файла впоследствии), а можно просто отправить по соединению из `Sort`, которое, в свою очередь, отправляет их следующему процессу, после завершения сортировки, что приводит к значительной экономии накладных расходов на ввод-вывод. Собственно, "центральная" фаза - сортировка — это единственная часть которая не может быть перекрыта другими процессами.
- Гибкость позиционирования "контрольных полей": если эти поля не находятся в стандартном месте для всех входных IP, вы можете просто вставить процесс преобразования выше по течению от сортировки, чтобы выровнять их.
- Устранение ненужной сортировки: иногда известно, что некоторые IP уже отсортированы, можно обойти их сортировку и позже объединить с отсортированными IP. Это часто нецелесообразно, если сортировка является отдельным этапом работы.
- Улучшенные методы сортировки: если вы знаете что-то о характеристиках ваших ключей, вы сможете создавать более сложные сети, которые работают лучше, чем прямая сортировка. Например, если вы сортируете по полю имени, может иметь смысл разделить данные на 26 путей (прим.пер - по букве английского алфавита), отсортировать каждый поток независимо, а затем снова объединить их вместе — я не утверждаю, что это определенно быстрее, но вы можете попробовать. Таким образом, процесс сортировки можно реализовать с другими компонентами или подсетями в экспериментальных целях.

Хотя некоторые сортировки выполняются быстрее, хорошее эмпирическое правило заключается - время выполнения большинства сортировок пропорционально `n.logn`, где `n` — количество записей. Поскольку это нелинейная связь, может быть более эффективно разделить сортировку на несколько отдельных.

Вот изображение сортировки с некоторыми IP, обходящими ее, и с тегами сортировки, генерируемыми на лету восходящим процессом (`GTAG`):

![fig8.6](http://www.jpaulmorrison.com/fbp/Fig8.6.gif)

Фрагмент 8.6
