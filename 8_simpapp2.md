# Построение компонентов и еще несколько простых приложений

Сейчас я собираюсь описать несколько простых приложений, сочетающих повторно используемые компоненты и пользовательские. Мы начнем с довольно простого приложения для обработки текста, чтобы сделать рассмотреть несколько моментов в дизайне FBP-приложений. Это классическая проблема программирования, первоначально описанная [Питером Науром](https://en.wikipedia.org/wiki/Peter_Naur), широко известная как [Проблема Телеграммы](https://wiki.c2.com/?TelegramProblem). Необходимо написать программу, которая принимает на вход строки текста и генерирует выходные строки разной длины, не разбивая ни одно из слов в тексте (мы предполагаем, что ни одно слово не длиннее, чем размер выходных строк). Это оказалось на удивление сложно сделать с помощью традиционного программировании, и потому эту задачу часто используют в качестве примера в курсах. Пока учащийся не осознает, что ни входная, ни выходная логика не должны быть "основной линией", а основная линия должен быть отдельным фрагментом кода, задача которого в обработке одного слова за раз, он вязнет в куче запутанной логики. В FBP гораздо более очевидно, как подойти к проблеме, по следующим причинам:

- Слова явно упоминаются в описании проблемы
- Поскольку мы должны выбирать наши IP между каждой парой процессов, разработчику разумно рассматривать слова как IP где-то в реализации задачи. На самом деле было бы нелогичным намеренно избегать превращения слов в IP, учитывая описание проблемы.
- Основого процесса нет, поэтому у ученика нет соблазна превратить одну из функций в основной процесс.

Вывод `Read Sequential` и ввод `Write Sequential` оба состоят из потоков IP, содержащих слова и пробелы, поэтому кажется разумным, что нам нужен, как минимум, компонент для разложения записей на слова и соответствующий компонент для перекомпоновки слов обратно в записи. Учитывая определение проблемы, я не вижу необходимости в дополнительных компонентах, но хочу подчеркнуть, что единого правильного ответа нет. Помните рентабельность инвестиций? **То, что вы выберете в качестве основных черных ящиков, зависит от того, насколько часто они будут использоваться, а не от того, сколько будет стоить их создание.**

Давайте поместим наши два новых компонента на картинку:

![fig8.2](http://www.jpaulmorrison.com/fbp/Fig8.2.gif)

Фрагмент 8.2

Теперь у нас есть еще одна пара компонентов — на диаграмме я обозначил их `DC` (для DeCompose) и `RC` (для ReCompose). Компоненты всегда могут узнать реальный размер любого IP, поэтому нам не нужно указывать размер входящих IP в `DC` в качестве параметра. Однако `RC` не может знать, какой размер IP мы хотим, чтобы он создал, поэтому этот размер должен быть передан в качестве параметра его порту `OPTIONS` (мы не обязаны называть его так, подойдёт любое имя). Итак, давайте покажем варианты IIP на `RC`. `RSEQ` и `WSEQ` также должны будут знать идентификаторы файлов, с которыми они работают, поэтому наша диаграмма теперь выглядит так:

![fig8.3](http://www.jpaulmorrison.com/fbp/Fig8.3.gif)

Фрагмент 8.3

Для полноты картины я приведу некоторый возможный псевдокод для `DC` и `RC`. Помните, как только вы написали и протестировали `DC` и `RC`, их можно применять бесконечно. Так что стоит приложить усилия, чтобы сделать их "идеальными" (настолько близкими к совершенству, насколько вообще может быть программное обеспечение!). Одним из больших преимуществ FBP является то, что вы можете просто вставить `Display` процесс в любое соединение, например, между `DC` и `RC`, чтобы убедиться, что IP, проходящие через это соединение, верны. Так что тестировать очень легко.

В дальнейшем я предположил (но не показал на схеме), что входной порт обоих компонентов называется `IN`, а выходной порт называется `OUT`.

**DC (Разбить в слова)**:

```
receive from IN using a

do while receive has not reached end of data
        do stepping through characters of input IP
                if "in word" switch is off and current char non-blank
                        set "in word" on
                        save character pointer // начало слова
                endif
                if "in word" on and current char blank // слово кончилось
                        set "in word" off
                        build new string of length =
                                current pointer - saved pointer // разность индексов есть длина слова
                        create IP using new string
                        send created IP to OUT
                endif
        enddo
        drop a (original input IP)
        receive from IN using a
enddo
```

**RC (Собрать в записи)**:

```
receive output record length from IIP port // OPTIONS порт, в примере выше 80
drop this IP

create output IP and set it to all blanks // используя полученную длину
start at beginning of output IP // установка курсора

receive word IP from IN using a
do while receive has not reached end of data
        if received word will not fit into output IP
                send output IP to OUT // в текущем виде
                create new output IP and set to all blanks
                start at beginning of output IP
        endif
        move contents of word IP into next space in output IP // а если не влезет?
        if there is room for 1 more character
                move in single blank
        endif
        drop a
        receive word IP from IN using a
        if receive reached end of data
                leave loop
        endif
enddo
if output IP has at least one word in it
        send output IP to OUT
else
        drop it
endif
```

_(Прим.Пер - все комментарии добавлены мной.)_

Может быть, эту логику можно упростить, но компонент не обязательно должен быть простым внутри — он должен быть простым снаружи, и прежде всего он должен работать надежно! Этот момент действительно иллюстрирует фундаментальное различие между традиционным программированием и FBP: я только что показал некоторый псевдокод, и вы можете почувствовать, будто мы вернулись к традиционному программированию. Однако, выразить то, что я пытаюсь сказать можно по-другому - **поскольку мы можем программировать, это не означает, что мы должны это делать**. Большинство традиционных подходов к программированию и даже некоторые новые объектно-ориентированные подходы по-прежнему требуют создания нового кода. Многие подходы к повторному использованию основаны на поиске доступного исходного кода и его повторном использовании. Поскольку код является такой податливой средой и не имеет встроенной структуры компонентов, мы всегда создаем новые вещи и забываем, что результаты нашей работы могут жить долго после нас и что их поддержка, документирование и управление требуют затрат. Сколько раз мы слышали: "Легче написать с нуля, чем разобраться, что там накручено"? В FBP ориентация совершенно обратная: используйте то, что есть, и создавайте новое только в том случае, если вы можете оправдать усилия с точки зрения рентабельности инвестиций. Именно здесь опыт становится ценным: после того, как вы много раз выполнили одну и ту же работу, вы знаете, сочтут ли другие люди полезными такие компоненты, как `DC` и `RC`. Если вы знаете, что они этого не сделают, найдите другой способ выполнить эту работу!

Теперь у нас есть ещё пара полезных компонентов, но, конечно же, вам не нужно постоянно использовать их вместе. Предположим, мы просто хотим подсчитать количество слов в фрагменте текста. Мы уже упоминали компонент `Count` в главе 3 — он просто подсчитывает все входящие IP и в конце генерирует IP счетчика. У него есть _параметр, чувствительный к подпотоку_ (он генерирует один IP-счётчик для каждого входящего подпотока), но сейчас мы будем использовать его в его самой базовой форме. В этой форме он просто отправляет только что рассчитанный счетчик через выходной порт, в то время как исходные входящие IP отправляются через другой, если он подключен (это пример _необязательного порта_). Этот тип компонента иногда называют "ссылающимся" компонентом, что означает, что исходные входные IP передаются без изменений, а некоторая производная информация отправляется из другого выходного порта. Таким образом, результирующая структура будет выглядеть примерно так (мы не будем подключать необязательный вывод Count):

![fig8.4](http://www.jpaulmorrison.com/fbp/Fig8.4.gif)

Фрагмент 8.4

Мы можем бесконечно добавлять или изменять процессы! Эти изменения могут быть результатом изменения требований, новых требований или просто осознания того, что вы можете использовать компонент, разработанный для одного приложения, в другом. В главе о повторном использовании мы говорили о некоторых принципах проектирования компонентов для повторного использования.

В качестве еще одного более сложного примера, вместо подсчета слов, мы могли бы отсортировать их по алфавиту или по длине. После того, как мы отсортировали бы слова в алфавитном порядке, было бы здорово иметь возможность вставлять причудливые заглавные буквы между группами слов, начинающихся с одинаковых букв, как в некоторых словарях... Конечно, после того, как мы их отсортировали, мы должны исключить дубликаты. Результирующая диаграмма будет выглядеть так (частично):

![fig8.5](http://www.jpaulmorrison.com/fbp/Fig8.5.gif)

Фрагмент 8.5

Где `RDUP` означает "Удалить дубликаты", а `IHDRS` означает "Вставить заглавные буквы".

Неудивительно, что приложения для обработки текста очень продуктивно работают с обобщенными компонентами. Это также область применения, в которой система UNIX® оказалась очень продуктивной. Механизм канала UNIX очень похож на потоки данных FBP, за исключением того, что связь UNIX основана на использовании потоков символов, тогда как связь FBP осуществляется посредством структурированных IP-адресов.

Прекрасным примером такого рода приложений для обработки текста является публикация П.Р.Юинга "[Конкорданс](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D0%BA%D0%BE%D1%80%D0%B4%D0%B0%D0%BD%D1%81) Украинской Библии" (1988 г.) — она была запрограммирована с использованием DFDM, и Филип обнаружил, что DFDM очень хорошо подходит для такого типа работы. Недавно он закончил Конкорданс для [Коса](<https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D1%81%D0%B0_(%D0%BD%D0%B0%D1%80%D0%BE%D0%B4)>) с помощью компьютерной программы THREADS. Он сообщает, что, потратив от 100 до 150 часов на разработку этого Конкорданса с использованием обычного (не FBP) программного обеспечения, ему в конце концов пришлось бросить его незаконченным. С помощью THREADS он смог создать законченный Конкорданс, потратив около 40 часов (конечно, не считая времени на ввод библейского текста). Он сказал мне, что, по его мнению, большим преимуществом FBP является тот факт, что оно упрощает сложность приложения, и 40 часов против более чем 100, безусловно, подтверждают это.

- Производительность: сортировка, которая выполняется как отдельный шаг, должна использовать файлы для ввода и вывода, а "контрольные поля" должны находиться в одном и том же месте в каждой входной записи. Если мы представим Sort как компонент, работающий "из потока в поток", то IP данных, которые должны быть отсортированы, больше не нужно сначала записывать в файл (и не нужно извлекать из файла впоследствии), а можно просто отправить по соединению из `Sort`, которое, в свою очередь, отправляет их следующему процессу, после завершения сортировки, что приводит к значительной экономии накладных расходов на ввод-вывод. Собственно, "центральная" фаза - сортировка — это единственная часть которая не может быть перекрыта другими процессами.
- Гибкость позиционирования "контрольных полей": если эти поля не находятся в стандартном месте для всех входных IP, вы можете просто вставить процесс преобразования выше по течению от сортировки, чтобы выровнять их.
- Устранение ненужной сортировки: иногда известно, что некоторые IP уже отсортированы, можно обойти их сортировку и позже объединить с отсортированными IP. Это часто нецелесообразно, если сортировка является отдельным этапом работы.
- Улучшенные методы сортировки: если вы знаете что-то о характеристиках ваших ключей, вы сможете создавать более сложные сети, которые работают лучше, чем прямая сортировка. Например, если вы сортируете по полю имени, может иметь смысл разделить данные на 26 путей (прим.пер - по букве английского алфавита), отсортировать каждый поток независимо, а затем снова объединить их вместе — я не утверждаю, что это определенно быстрее, но вы можете попробовать. Таким образом, процесс сортировки можно реализовать с другими компонентами или подсетями в экспериментальных целях.

Хотя некоторые сортировки выполняются быстрее, хорошее эмпирическое правило заключается - время выполнения большинства сортировок пропорционально `n.logn`, где `n` — количество записей. Поскольку это нелинейная связь, может быть более эффективно разделить сортировку на несколько отдельных.

Вот изображение сортировки с некоторыми IP, обходящими ее, и с тегами сортировки, генерируемыми на лету восходящим процессом (`GTAG`):

![fig8.6](http://www.jpaulmorrison.com/fbp/Fig8.6.gif)

Фрагмент 8.6

На самом деле сортировка — это пример того, что я открыл довольно рано в работе над FBP: FBP позволяет вам связать воедино вещи, которые, казалось бы, не должны были быть связаны! Если вы можете убедить что-то принимать и генерировать пакеты данных, то оно может общаться с другими штуками, которые "разговаривают" данными. Например, после того как вы преобразовали `Sort` в _потоковый_ компонент, он может взаимодействовать с другими утилитами, HLL, [DB2](https://en.wikipedia.org/wiki/IBM_Db2_Family) и т.д. Они не обязательно должны быть вызываемыми — они просто должны иметь возможность принимать и генерировать данные после того, как им будет передано управление. Я писал сети, которые содержали программы на ассемблере, COBOL и PL/I, всё в одной сети. Я также создал приложение, которое использовало диспетчер экрана, написанный на ассемблере, REXX для всей логики вычислений, использовал повторно используемые компоненты для управления экраном и [GDDM/PGF](https://en.wikipedia.org/wiki/Graphical_Data_Display_Manager) для рисования диаграмм по запросу пользователя. Другая сеть охватывает две виртуальные машины CMS, взаимодействующие посредством [VMCF](https://en.wikipedia.org/wiki/Virtual_Machine_Communication_Facility). К этому моменту мы вернемся позже: **вы можете спроектировать большую сеть, а затем разделить ее на разные машины, процессоры, программные системы и т.д**.

Между прочим, у этой способности связывать вещи вместе «без их ведома» есть обратная сторона: выше мы упомянули тот факт, что **компоненты должны быть [реентерабельными](<https://en.wikipedia.org/wiki/Reentrancy_(computing)>)**, если они собираются выполнять многопоточность друг с другом. Странные вещи случаются, если вы пытаетесь использовать многопоточные процессы, которые не являются реентерабельными! После того, как мы превратили сортировку в процесс «поток-поток», казалось разумным захотеть запустить более одного процесса сортировки в одной сети. Пока один был полностью завершен до того, как начался другой, у нас не было проблем. Когда мы попытались совместить два `Sort`'а во времени, произошли странные вещи. Мы подозревали, что реентерабельность нарушается, но это не всегда вызывало проблемы. Некоторые люди сообщали, что все работало нормально, другие, что всегда зависало! После того, как мы исключили возможность того, что это было вызвано программистом, мы в конце концов выяснили, что некоторые методы сортировки, используемые Sort, были реентерабельными (вероятно, более поздние), а некоторые нет, поэтому некоторые форматы файлов или объемы вызывали проблемы (потому что они запускали разные методы сортировки), а другие — нет. Мы решили, что безопаснее всего заблокировать сортировки таким образом, чтобы одна из них не могла начаться, пока не завершится другая (это не лучшее решение, так как оно требует решения, какая сортировка должна запускаться первой, что, как вы, вероятно, уже поняли к настоящему времени, противоречит философии FBP).

> Этот анекдот напоминает мне о ловушке при использовании `Writer` для записи в [PDS](<https://en.wikipedia.org/wiki/Data_set_(IBM*mainframe)#Partitioned_data_set>) под IBM MVS (даже если вы не являетесь пользователем MVS, другие операционные системы поддерживают аналогичные структуры, так что это может быть поучительно). PDS — это наборы данных, которые содержат ряд подфайлов (элементов) с директорией в начале. Некоторые программисты использовали по несколько экземпляров компонента `Writer` в DFDM, чтобы записывать более одного элемента за раз. Но результаты, внезапно, смешались! В MVS мы настолько привыкли обращаться с элементами PDS, как с обычными файлами, что было вовсе не очевидным, почему одновременная запись двух или более файлов должна вызывать проблемы. Конечно, в тот момент, когда вам на это указывают, становится очевидным: PDS «растут» с конца. Если в PDS уже есть элемент «A», и вы решили записать элемент «A», то произойдёт следующее: вы записываете новые данные в конец PDS, а затем, когда новый элемент записан, каталог обновляется, чтобы указывать на новый элемент (оставляя так называемый "газ" посередине (если вы обновляете элемент PDS или элемент был удален)). Если вы попытаетесь одновременно записать два элемента, два процесса записи увидят один и тот же «конец PDS» и оба начнут запись в одном и том же месте. Затем два процесса поочередно записывают блоки, после чего обе записи каталога обновляются, указывая на старый конец PDS!

![fig8.7](http://www.jpaulmorrison.com/fbp/Fig8.7.gif)

Фрагмент 8.7

Теперь давайте вернемся к исходной задаче Telegram, но сначала запрограммируем ее используя обычное (с потоком управления) программирование. Надеюсь, зачем - скоро станет ясно.

Из приведенного выше обсуждения мы видим, что слова являются ключевой концепцией, необходимой для решения этой проблемы. Как только мы это осознаем, мы можем продолжить и закодировать это, используя что-то вроде следующей иерархии вызовов:

![fig8.8](http://www.jpaulmorrison.com/fbp/Fig8.8.gif)

Фрагмент 8.8

Как мы уже говорили выше, в обычном программировании поначалу совсем не очевидно, что это правильный способ решения этой задачи. Большинство людей, занимающихся этой проблемой, начинают с того, что делают `GETWORD` или `PUTWORD` программой-боссом, и сразу же попадают в беду. Итак, теперь мы понимаем, что нам нужно «привести босса извне» (назовем его `MAIN`), вместо того, чтобы «продвигать» `GETWORD` или `PUTWORD` до босса. Теперь `MAIN` может вызывать `GETWORD` и `PUTWORD` для извлечения и сохранения по одному слову за раз соответственно. Для этого `GETWORD`, в свою очередь, должен вызвать `GETREC`, а `PUTWORD` должен вызвать `PUTREC`, чтобы следить за вводом-выводом. Теперь обратите внимание, что все 4 эти подпрограммы должны «держать свое место» в потоках данных (потоках слов или потоках записей). В прежние времена мы делали это, записывая их как нереентерабельный код, поэтому информация-заполнитель по существу становилась глобальной информацией. Это совершенно справедливо осуждается как плохая практика, так ибо имеет ряд существенных недостатков, поэтому сегодня мы обычно управляем такой логикой размещения, используя концепцию «дескрипторов». Общая идея (для тех из вас, кому не приходилось бороться с такой логикой) заключается в том, что `MAIN` передает нулевой дескриптор (во многих системах это будет указатель, изначально установленный в ноль) в `GETWORD`. Когда `GETWORD` видит нулевой дескриптор, он выделяет блок памяти и помещает его адрес в дескриптор. После этого он использует этот блок памяти косвенно через дескриптор, а в конце выполнения снова освобождает его. Хотя этот блок памяти выделяется и освобождается `GETWORD`, считается, что он принадлежит `MAIN`. Эта же логика также используется между `MAIN` и `PUTWORD`, между `GETWORD` и `GETREC`, а также между `PUTWORD` и `PUTREC`. На базовом уровне наша проблема заключается в том, что **подпрограммы не могут хранить внутреннюю информацию, которая сохраняется дольше одного вызова**. Напротив, **компоненты FBP представляют собой долговременные объекты, хранящие собственную внутреннюю информацию. Их не нужно постоянно повторно вызывать — вы просто запускаете их, и они работают до тех пор, пока их входные потоки не будут исчерпаны.** Таким образом, компоненты FBP могут делать то же самое, что и подпрограммы, но более устойчивым способом, что представляет значительный интерес для наших будущих потребностей, а также более распространяемым. Важно отметить, что FBP не мешает нам использовать подпрограммы, но мой опыт показывает, что они наиболее подходят для таких задач, как математические вычисления с несколькими переменными, поиск в таблицах, доступ к базам данных и т.д. другими словами, задачи, максимально соответствующие математической идее функции. О таких подпрограммах говорят, что они «свободны от побочных эффектов», и опыт показывает, что **побочные эффекты являются одной из наиболее распространенных причин программных ошибок**. Следовательно, **подпрограммы, которые полагаются на побочные эффекты для своего правильного функционирования, являются довольно плохой основой для создания сложного программного обеспечения**!

А теперь, чтобы вернуть вас в духу потоков данных, давайте поговорим о примере обработки текста, что я описывал выше. Где мы хотим взять некоторый текст, разделить его на отдельные слова, отсортировать их, удалить дубликаты, вставить причудливые буквы при каждой смене буквы и распечатать результат. О, и давайте распечатаем это в две колонки! Используя FBP, это довольно просто — на самом деле, **мы только что описали структуру сети FBP**! Пусть это будет вашим домашним заданием, читатель. Здесь также иллюстрируется точка зрения (покойного системного архитектора) Уэйна Стивенса, на которую я часто обращал внимание, а именно, что **мы очень часто хотим связать целый набор функций вместе последовательным образом**. Мы говорим "сделать А, В, С, и ...", что по сути то же самое, что "взять вывод А и передать его В; затем взять вывод В и передать его С и так далее". Точно также как работают конвейеры системы UNIX или MS DOS. Это очень естественная и важная функция, и очень важно уметь выражать такую связь минимальным количеством нажатий клавиш. В интерпретируемой нотации DFDM и THREADS мы используем два нажатия клавиш `->` для представления этой связи.

До сих пор мы работали с довольно простыми структурами, которые либо объединяли «фильтры» в то, что иногда зовётся «ниткой жемчуга», либо один поток данных генерировал более одного («расходящиеся» паттерны). Следует обратить внимание на расходящиеся потоки: **как только два потока расходятся, они больше не будут синхронизированы**. **Некоторые программные системы прилагают большие усилия для их синхронизации, но наш опыт показывает, что в большинстве случаев это не является ни необходимости ни желанным**. Есть способы повторно синхронизировать их, если вам **действительно** это нужно, но вы можете обнаружить, что это не стоит того! На минуточку, в главе о взаимоблокировках мы увидим, что повторная синхронизация является потенциальной их причиной.

Люди очень часто разделяют потоки данных, чтобы разные части их сетей могли обрабатывать разные типы IP — это работает лучше всего, если вам не нужно сохранять какие-либо временные отношения между разными типами. Если вы это сделаете, есть вариант метода «нитки жемчуга», который может оказаться полезным: пусть каждая «жемчужина» следит за одним типом IP и пропускает через себя все остальные. Тогда его (частичный) псевдокод будет выглядеть следующим образом:

```
receive from port IN using a
if type is XXX
        process type XXX
endif
send a to port OUT
```

Затем вы можете связать столько из них вместе, сколько хотите, и каждая жемчужина будет заботиться о своем собственном типе данных и игнорировать все остальные.

Теперь пришло время поговорить о различных типах функции слияния. Прямо в FBP встроено базовое слияние — слияние в порядке очереди. Это делается очень просто путем подключения двух или более выходных портов к одному входному порту следующим образом:

![fig8.9](http://www.jpaulmorrison.com/fbp/Fig8.9.gif)

Фрагмент 8.9

Где порты `OUT` из `A` и `OUT` из `B` поступают в порт `IN` из `C`. IP, отправляемые по этому соединению на порт `IN` из `C`, будут поступать с чередованием. **IP, отправленные одним процессом, по-прежнему будут поступать в правильной последовательности, но их последовательность относительно вывода другого процесса будет непредсказуемой**. Как часто такое может понадобиться? На удивление часто! `C` может быть `Sort`, поэтому последовательность его входящих IP в любом случае будет изменена. IP из двух выходных потоков могут быть легко различимы, поэтому мы всегда можем разделить их позже. `C` может быть заинтересован в получении своих входных данных как можно быстрее — любое дополнительное упорядочивание может вызвать задержки и фактически даже привести к взаимоблокировкам.

Если же слияние в порядке очереди окажется неподходящим, нам понадобится процесс на стыке двух потоков. Это может быть пользовательский компонент слияния, или вы можете использовать один из компонентов, поставляемых из коробки, например `Collate` или `Merge`. Оба они используют один или несколько порт-элементов одного массива портов для обработки своих входных потоков, поэтому мы будем использовать это соглашение. Потому что они могут обрабатывать любое количество входных потоков насколько позволяет реализация. Конечно, в пользовательских компонентах один входной порт может называться `JOE`, а другой — `JIM` — это зависит от разработчика (конечно, при условии, что пользователи компонента смирятся с этим!)

Теперь наша диаграмма выглядит так:

![fig8.10](http://www.jpaulmorrison.com/fbp/Fig8.10.gif)

Фрагмент 8.10

- `OUT` из `A` подключен к `IN[0]` из `C`
- `OUT` из `B` подключен к `IN[1]` из из `C`
- `OUT` из `C` подключен к `IN` из `D`

Если `C` является `Collate`, то выходные данные `A` будут объединены с выходными данными `B` в соответствии со значениями ключей — обычно ключевые поля указываются для `Collate` с помощью IP опций. В качестве альтернативы `Collate` может использовать одно или несколько именованных полей, которые будут связаны с IP посредством дескрипторов (см. соотв. главу). Можно также представить `Collate` компоненты, чувствительные к подпотоку — **мы можем захотеть объединить подпотоки на основе определенного поля в первом IP каждого подпотока**.

Наконец, если бы мы использовали `Concatenate` вместо `Collate`, то мы хотели бы, чтобы `C` отправил весь вывод `A` в `D`, прежде чем он примет какой-либо вывод от `B`. Как мы уже говорили выше, есть ситуации, когда это тоже может быть полезно. `Collate`, однако, является очень мощным компонентом и в сочетании с идеями, описанными в следующей главе, значительно упрощает прикладные программы, которые были бы чрезвычайно сложными при использовании обычных методов программирования.
